[
  {
    "objectID": "simulation_study.html",
    "href": "simulation_study.html",
    "title": "Simulation study",
    "section": "",
    "text": "library(INLA)\n\nLoading required package: Matrix\n\n\nLoading required package: foreach\n\n\nLoading required package: parallel\n\n\nLoading required package: sp\n\n\nThis is INLA_22.05.03 built 2022-05-03 08:04:26 UTC.\n - See www.r-inla.org/contact-us for how to get help.\n - To enable PARDISO sparse library; see inla.pardiso()\n\nlibrary(inlabru)\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n\n\n✔ ggplot2 3.3.6      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.2      ✔ forcats 0.5.1 \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ purrr::accumulate() masks foreach::accumulate()\n✖ tidyr::expand()     masks Matrix::expand()\n✖ dplyr::filter()     masks stats::filter()\n✖ dplyr::lag()        masks stats::lag()\n✖ tidyr::pack()       masks Matrix::pack()\n✖ tidyr::unpack()     masks Matrix::unpack()\n✖ purrr::when()       masks foreach::when()\nIn the vignette Simulation example, we simulate a single data set with Berkson error, classical error and missing data, and then fit a measurement error model to adjust for these errors. In this simulation study, we do the exact same steps, but repeated on 100 simulated data sets instead of just one, to ensure that the results are not an artifact of one particular data set. This vignette consists of mostly just code, for detailed explanations on the steps taken in the analysis, please refer to Simulation example.\nTODO: The model in this vignette still uses the random effect berkson model, this needs to be changes. Make sure model is consistent with the model in the Simulation example vignette."
  },
  {
    "objectID": "simulation_study.html#function-for-simulating-data",
    "href": "simulation_study.html#function-for-simulating-data",
    "title": "Simulation study",
    "section": "Function for simulating data",
    "text": "Function for simulating data\n\nsimulate_data <- function(n){\n  # Covariate without error:\n  z <- rnorm(n, mean = 0, sd = 1)\n  # Berkson error:\n  u_b <- rnorm(n)\n  w_b <- rnorm(n, mean = 1 + 2*z, sd = 1)\n  x <- w_b + u_b\n  # Response:\n  y <- 1 + 2*x + 2*z + rnorm(n)\n  # Classical error:\n  u_c <- rnorm(n)\n  w_c <- x + u_c # I think maybe this is incorrect, shouldn't we be using w_b here?\n  # Missingness:\n  m_pred <- -1.5 - 0.5*z # This gives a mean probability of missing of ca 0.2.\n  m_prob <- exp(m_pred)/(1 + exp(m_pred))\n  m_index <- rbinom(n, 1, prob = m_prob) # MAR\n  # m_index <- sample(1:n, 0.2*n, replace = FALSE) # MCAR\n  w_c[m_index] <- NA\n\n  simulated_data <- data.frame(y = y, w = w_c, z = z, x = x)\n  return(simulated_data)\n}"
  },
  {
    "objectID": "simulation_study.html#functions-for-setting-up-the-model-matrices",
    "href": "simulation_study.html#functions-for-setting-up-the-model-matrices",
    "title": "Simulation study",
    "section": "Functions for setting up the model matrices",
    "text": "Functions for setting up the model matrices\n\n# Make matrix for ME model\nmake_matrix_ME <- function(data){\n  n <- nrow(data)\n  \n  y <- data$y\n  w <- data$w\n  z <- data$z\n  \n  # Measurement error model\n  Y <- matrix(NA, 3*n, 3)\n  \n  Y[1:n, 1] <- y               # Regression model of interest response\n  Y[n+(1:n), 2] <- w           # Error model response\n  Y[2*n+(1:n), 3] <- rep(0, n) # Exposure model response\n  \n  beta.0 <- c(rep(1, n), rep(NA, 2*n))\n  beta.x <- c(1:n, rep(NA, n), rep(NA, n))\n  u.b.tilde <- c(1:n, rep(NA, n), rep(NA, n))\n  beta.z <- c(z, rep(NA, 2*n))\n  \n  id.r <- c(rep(NA, n), 1:n, 1:n)\n  weight.r <- c(rep(1, n), rep(1, n), rep(-1, n))\n  \n  alpha.0 = c(rep(NA, n), rep(NA, n), rep(1, n))\n  alpha.z = c(rep(NA, n), rep(NA, n), z)\n  dd_adj <- list(Y = Y,\n                   beta.0 = beta.0,\n                   beta.x = beta.x,\n                   u.b.tilde = u.b.tilde,\n                   beta.z = beta.z,\n                   id.r = id.r,\n                   weight.r = weight.r,\n                   alpha.0 = alpha.0,\n                   alpha.z = alpha.z)\n\n  return(dd_adj)\n}\n\n# Make matrix for naive model\nmake_matrix_naive <- function(data){\n  y <- data$y\n  w <- data$w\n  z <- data$z\n  \n  # Naive model\n  dd_naive <- data.frame(Y = y,\n                         beta.0 = rep(1, nrow(data)),\n                         beta.x = w, \n                         beta.z = z)\n  return(dd_naive)\n}\n\n# Make matrix for model using the unobserved variable\nmake_matrix_true <- function(data){\n  y <- data$y\n  x <- data$x\n  z <- data$z\n  # True model\n  dd_naive <- data.frame(Y = y,\n                         beta.0 = rep(1, nrow(data)),\n                         beta.x = x, \n                         beta.z = z)\n}"
  },
  {
    "objectID": "simulation_study.html#function-for-fitting-the-me-model",
    "href": "simulation_study.html#function-for-fitting-the-me-model",
    "title": "Simulation study",
    "section": "Function for fitting the ME model",
    "text": "Function for fitting the ME model\n\n# Fit ME model\nfit_model_ME <- function(data_matrix) {\n  # Priors for model of interest coefficients\n  prior.beta <- c(0, 1/1000) # N(0, 10^3)\n  \n  # Priors for exposure model coefficients\n  prior.alpha <- c(0, 1/10000) # N(0, 10^4)\n  \n  # Priors for y, measurement error and true x-value precision\n  prior.prec.y <- c(0.5, 0.5) # Gamma(0.5, 0.5)\n  prior.prec.u_b <- c(0.5, 0.5) # Gamma(0.5, 0.5)\n  prior.prec.u_c <- c(0.5, 0.5) # Gamma(0.5, 0.5)\n  prior.prec.x <- c(0.5, 0.5) # Gamma(0.5, 0.5)\n  \n  # Initial values\n  prec.y <- 1\n  prec.u_b <- 1\n  prec.u_c <- 1\n  prec.x <- 1\n  \n  # Formula\n  formula <- Y ~ beta.0 - 1 +\n    f(beta.x, copy=\"id.r\",\n      hyper = list(beta = list(param = prior.beta, fixed=FALSE))) +\n    f(id.r, weight.r, model=\"iid\", values = 1:n,\n      hyper = list(prec = list(initial = -15, fixed=TRUE))) +\n    f(u.b.tilde, model = \"iid\", values = 1:n,\n      hyper = list(prec = list(initial = log(1), fixed=TRUE))) +\n    beta.z + alpha.0 + alpha.z\n  \n  # Fit model\n  model <- inla(formula,\n                data = data_matrix,\n                family = c(\"gaussian\", \"gaussian\", \"gaussian\"),\n                control.family = list(\n                  list(hyper = list(prec = list(initial = log(prec.y), \n                                                param = prior.prec.y, \n                                                fixed = FALSE))), \n                  list(hyper = list(prec = list(initial = log(prec.u_c), \n                                                param = prior.prec.u_c, \n                                                fixed = TRUE))), \n                  list(hyper = list(prec = list(initial = log(prec.x), \n                                                param = prior.prec.x, \n                                                fixed = FALSE)))), \n                control.predictor = list(compute = TRUE), \n                control.fixed = list(\n                  mean = list(\n                    beta.0 = prior.beta[1],\n                    beta.z = prior.beta[1],\n                    alpha.0 = prior.alpha[1],\n                    alpha.z = prior.alpha[1]),\n                  prec = list(\n                    beta.0 = prior.beta[2],\n                    beta.z = prior.beta[2],\n                    alpha.0 = prior.alpha[2],\n                    alpha.z = prior.alpha[2])\n    )\n  )\n}"
  },
  {
    "objectID": "simulation_study.html#function-for-fitting-the-truenaive-model",
    "href": "simulation_study.html#function-for-fitting-the-truenaive-model",
    "title": "Simulation study",
    "section": "Function for fitting the true/naive model",
    "text": "Function for fitting the true/naive model\nThe same function can be used to fit the naive model (y ~ w + z) and the best-case model (y ~ x + z) since they simply differ in the variable that is inputted (w versus x).\n\nfit_model_naive_true <- function(data_matrix){\n  # Priors for model of interest coefficients\n  prior.beta <- c(0, 1/1000) # N(0, 10^3)\n\n  # Priors for y, measurement error and true x-value precision\n  prior.prec.y <- c(0.5, 0.5) # Gamma(0.5, 0.5)\n  \n  # Initial values\n  prec.y <- 1\n\n  # Formula\n  formula <- Y ~ beta.0 - 1 + beta.x + beta.z\n  \n  # Fit model\n  model <- inla(formula,\n                data = data_matrix,\n                family = c(\"gaussian\"),\n                control.family = list(\n                  list(hyper = list(prec = list(initial = log(prec.y), \n                                                param = prior.prec.y, \n                                                fixed = FALSE)))),\n                control.fixed = list(\n                  mean = list(\n                    beta.0 = prior.beta[1],\n                    beta.z = prior.beta[1],\n                    beta.x = prior.beta[1]),\n                  prec = list(\n                    beta.0 = prior.beta[2],\n                    beta.z = prior.beta[2],\n                    beta.x = prior.beta[2])\n    )\n  )\n}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Supplementary material and reproducible research files for article “A Joint Bayesian Framework for Measurement Error and Missing Data using Integrated Nested Laplace Approximations”",
    "section": "",
    "text": "Authors: Skarstein, E., Martino, S., Muff, S.\nThis supplementary material was written by Skarstein, E., but code for analysis was developed jointly between authors.\nIn case of any questions or comments, please do not hesitate to contact emma.s.skarstein@ntnu.no!\nThis website contains scripts, tutorials and data to reproduce all analysis and figures from the manuscript."
  },
  {
    "objectID": "index.html#examples",
    "href": "index.html#examples",
    "title": "Supplementary material and reproducible research files for article “A Joint Bayesian Framework for Measurement Error and Missing Data using Integrated Nested Laplace Approximations”",
    "section": "Examples",
    "text": "Examples\nThese include scripts to run the code for analysis, including comments and explanations.\n\nSimulation example\nSimulation study\nMissing value imputation using INLA\nMissing and mismeasured covariates\nExamples in ‘inlabru’"
  },
  {
    "objectID": "index.html#data",
    "href": "index.html#data",
    "title": "Supplementary material and reproducible research files for article “A Joint Bayesian Framework for Measurement Error and Missing Data using Integrated Nested Laplace Approximations”",
    "section": "Data",
    "text": "Data\nAll the data sets that are used in the paper can be downloaded manually from [link to github repo], or like this:\n\n# Code to download data"
  },
  {
    "objectID": "index.html#session-info",
    "href": "index.html#session-info",
    "title": "Supplementary material and reproducible research files for article “A Joint Bayesian Framework for Measurement Error and Missing Data using Integrated Nested Laplace Approximations”",
    "section": "Session info",
    "text": "Session info\nThe code was written and run in R with the following software versions:\n\n\n\n Current session info \n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.0 (2022-04-22)\n os       macOS Catalina 10.15.7\n system   x86_64, darwin17.0\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Zurich\n date     2022-10-25\n pandoc   2.18 @ /Applications/RStudio.app/Contents/MacOS/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package      * version  date (UTC) lib source\n   codetools      0.2-18   2020-11-04 [1] CRAN (R 4.2.0)\n   foreach        1.5.2    2022-02-02 [1] CRAN (R 4.2.0)\n   INLA           22.05.03 2022-05-03 [1] local\n   inlabru        2.5.2    2022-03-30 [1] CRAN (R 4.2.0)\n   iterators      1.0.14   2022-02-05 [1] CRAN (R 4.2.0)\n   lattice        0.20-45  2021-09-22 [1] CRAN (R 4.2.0)\n   magrittr       2.0.3    2022-03-30 [1] CRAN (R 4.2.0)\n   Matrix         1.4-1    2022-03-23 [1] CRAN (R 4.2.0)\n   MatrixModels   0.5-0    2021-03-02 [1] CRAN (R 4.2.0)\n   plyr           1.8.7    2022-03-24 [1] CRAN (R 4.2.0)\n   Rcpp           1.0.9    2022-07-08 [1] CRAN (R 4.2.0)\n R rgdal          <NA>     <NA>       [?] <NA>\n   rgeos          0.5-9    2021-12-15 [1] CRAN (R 4.2.0)\n   rlang          1.0.6    2022-09-24 [1] CRAN (R 4.2.0)\n   sp             1.5-0    2022-06-05 [1] CRAN (R 4.2.0)\n   withr          2.5.0    2022-03-03 [1] CRAN (R 4.2.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.2/Resources/library\n\n R ── Package was removed from disk.\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "example_in_inlabru.html",
    "href": "example_in_inlabru.html",
    "title": "Example in inlabru",
    "section": "",
    "text": "We here show how to fit the measurement error and missing data model in inlabru. The inlabru code is written by Sara Martino, and commented by Emma Skarstein.\n\nLoading the data\nFor this demonstration we will use the simulated data from the “Simulation example” vignette. Just to refresh: this is a situation where we have one covariate (\\(\\boldsymbol{x}\\)) that has both classical error, Berkson error and missing data. We also observe another covariate (\\(\\boldsymbol{z}\\)) that has no error.\n\ndata <- read.csv(\"data/simulated_data.csv\")\nn <- nrow(data)\n\n\n\nPriors\nWe use the exact same priors as in the original simulation study.\n\n# Priors for model of interest coefficients\nprior.beta = c(0, 1/1000) # N(0, 10^3)\n\n# Priors for exposure model coefficients\nprior.alpha <- c(0, 1/10000) # N(0, 10^4) \n\n# Priors for y, measurement error and true x-value precision\nprior.prec.y <- c(0.5, 0.5) # Gamma(0.5, 0.5)\nprior.prec.u_b <- c(0.5, 0.5) # Gamma(0.5, 0.5)\nprior.prec.u_c <- c(0.5, 0.5) # Gamma(0.5, 0.5)\nprior.prec.x <- c(0.5, 0.5) # Gamma(0.5, 0.5) \n\n# Initial values\nprec.y <- 1\nprec.u_b <- 1\nprec.u_c <- 1\nprec.x <- 1\n\n\n\nFirst version – using the copy option\nThis is a direct translation of the INLA code.\n\ndata1 = data.frame(y = data$y, z = data$z, weight = 1, r = 1:n)\ndata2 = data.frame(w = data$w,  weight = 1, r = 1:n)\ndata3 = data.frame(zero = 0, z = data$z,  weight = -1, r = 1:n)\n\n\ncmp = ~ Intercept(1, model = \"linear\", prec.linear = prior.beta[2]) +\n  beta_z(main = z, model = \"linear\", prec.linear = prior.beta[2]) +\n  u_b(main = r, model = \"iid\",  hyper = list(prec = list(initial = log(1), fixed=TRUE))) +\n  r_eff(r, weight, model = \"iid\",  hyper = list(prec = list(initial = -15, fixed=TRUE))) +\n  r_eff_copy(r, copy=\"r_eff\", \n             hyper = list(beta = list(param = prior.beta, fixed=FALSE))) +\n  alpha_0(main = 1, model = \"linear\", prec.linear = prior.alpha[2]) +\n  alpha_z(main = z, model = \"linear\", prec.linear = prior.alpha[2])\n\n\nlik1 = like(formula = y ~ Intercept + beta_z + u_b + r_eff_copy,\n            family = \"gaussian\",\n            include = c(\"Intercept\",\"beta_z\",\"u_b\",\"r_eff_copy\"),\n            control.family = list(hyper = list(prec = list(initial = log(prec.y), \n                                                           param = prior.prec.y, \n                                                           fixed = FALSE))),\n            data = data1)\n\nlik2 = like(formula = w ~ r_eff,\n            family = \"gaussian\",\n            include = c(\"r_eff\"),\n            control.family =  list(hyper = list(prec = list(initial = log(prec.u_c), \n                                                            param = prior.prec.u_c, \n                                                            fixed = TRUE))),\n            data  = data2)\n\nlik3  = like(formula = zero ~ alpha_0 + alpha_z + r_eff,\n             family = \"gaussian\",\n             include = c(\"alpha_0\", \"alpha_z\",\"r_eff\"),\n             control.family =   list(hyper = list(prec = list(initial = log(prec.x), \n                                                              param = prior.prec.x, \n                                                              fixed = FALSE))),\n             data = data3)\n# Note: \n# formula = y ~ .,\n# formula = w ~ .,\n# formula = zero ~ .,\n# does exactly the same.\n\n\nbru_options_set(bru_verbose = 1)\nfit = bru(components = cmp,\n          lik1,\n          lik2,\n          lik3,\n          options = list(verbose = F,\n                         bru_max_iter = 20,\n                         inla.mode  = \"experimental\"))\n\niinla: Iteration 1 [max:20]\n\n\niinla: Iteration 2 [max:20]\n\n\niinla: Max deviation from previous: 154% of SD [stop if: <1%]\n\n\niinla: Iteration 3 [max:20]\n\n\niinla: Max deviation from previous: 158% of SD [stop if: <1%]\n\n\niinla: Iteration 4 [max:20]\n\n\niinla: Max deviation from previous: 156% of SD [stop if: <1%]\n\n\niinla: Iteration 5 [max:20]\n\n\niinla: Max deviation from previous: 158% of SD [stop if: <1%]\n\n\niinla: Iteration 6 [max:20]\n\n\niinla: Max deviation from previous: 156% of SD [stop if: <1%]\n\n\niinla: Iteration 7 [max:20]\n\n\niinla: Max deviation from previous: 157% of SD [stop if: <1%]\n\n\niinla: Iteration 8 [max:20]\n\n\niinla: Max deviation from previous: 154% of SD [stop if: <1%]\n\n\niinla: Iteration 9 [max:20]\n\n\niinla: Max deviation from previous: 155% of SD [stop if: <1%]\n\n\niinla: Iteration 10 [max:20]\n\n\niinla: Max deviation from previous: 153% of SD [stop if: <1%]\n\n\niinla: Iteration 11 [max:20]\n\n\niinla: Max deviation from previous: 154% of SD [stop if: <1%]\n\n\niinla: Iteration 12 [max:20]\n\n\niinla: Max deviation from previous: 154% of SD [stop if: <1%]\n\n\niinla: Iteration 13 [max:20]\n\n\niinla: Max deviation from previous: 155% of SD [stop if: <1%]\n\n\niinla: Iteration 14 [max:20]\n\n\niinla: Max deviation from previous: 151% of SD [stop if: <1%]\n\n\niinla: Iteration 15 [max:20]\n\n\niinla: Max deviation from previous: 152% of SD [stop if: <1%]\n\n\niinla: Iteration 16 [max:20]\n\n\niinla: Max deviation from previous: 150% of SD [stop if: <1%]\n\n\niinla: Iteration 17 [max:20]\n\n\niinla: Max deviation from previous: 151% of SD [stop if: <1%]\n\n\niinla: Iteration 18 [max:20]\n\n\niinla: Max deviation from previous: 150% of SD [stop if: <1%]\n\n\niinla: Iteration 19 [max:20]\n\n\niinla: Max deviation from previous: 145% of SD [stop if: <1%]\n\n\niinla: Maximum iterations reached, running final INLA integration.\n\n\niinla: Iteration 20 [max:20]\n\nfit$summary.fixed\n\n               mean         sd 0.025quant  0.5quant 0.975quant mode\nIntercept 1.0833013 0.06574591  0.9537734 1.0838473  1.2097886   NA\nbeta_z    0.9647166 0.05696265  0.8520621 0.9651042  1.0752416   NA\nalpha_0   1.0495269 0.05879511  0.9342711 1.0495000  1.1649354   NA\nalpha_z   0.6010181 0.05984694  0.4836521 0.6010078  0.7184423   NA\n                   kld\nIntercept 4.535895e-08\nbeta_z    5.684490e-09\nalpha_0   2.087570e-11\nalpha_z   3.332226e-12\n\n\n\n\nSecond version – no copy option\nThis takes advantage of special inlabru features.\n\n# no copy -----------------------------------------------------------------\n\ncmp2 = ~ Intercept(1, model = \"linear\", prec.linear = prior.beta[2]) +\n  beta_z(main = z, model = \"linear\", prec.linear = prior.beta[2]) +\n  u_b(main = r, model = \"iid\",  hyper = list(prec = list(initial = log(1), fixed=TRUE))) +\n  r_eff(r, weight, model = \"iid\",  hyper = list(prec = list(initial = -15, fixed=TRUE))) +\n  #  r_eff_copy(r, copy=\"r_eff\", \n  #             hyper = list(beta = list(param = prior.beta, fixed=FALSE))) +\n  beta_u(main = 1, model = \"linear\", prec.linear = 0.001) +\n  alpha_0(main = 1, model = \"linear\", prec.linear = prior.alpha[2]) +\n  alpha_z(main = z, model = \"linear\", prec.linear = prior.alpha[2])\n\n\nlik1 = like(formula = y ~ Intercept + beta_z + u_b + beta_u * r_eff ,\n            family = \"gaussian\",\n            data = data1,\n            include = c(\"Intercept\",\"beta_z\",\"u_b\",\"beta_u\", \"r_eff\"),\n            control.family = list(hyper = list(prec = list(initial = log(prec.y), \n                                                           param = prior.prec.y, \n                                                           fixed = FALSE))))\n\nlik2 = like(formula = w ~ .,\n            family = \"gaussian\",\n            include = c(\"r_eff\"),\n            control.family =  list(hyper = list(prec = list(initial = log(prec.u_c), \n                                                            param = prior.prec.u_c, \n                                                            fixed = TRUE))),\n            data  = data2)\n\nlik3  = like(formula = zero ~ . ,\n             data = data3,\n             family = \"gaussian\",\n             include = c(\"alpha_0\", \"alpha_z\",\"r_eff\"),\n             control.family =   list(hyper = list(prec = list(initial = log(prec.x), \n                                                              param = prior.prec.x, \n                                                              fixed = FALSE))))\n\n\n\nbru_options_set(bru_verbose = 1)\nfit2 = bru(components = cmp2,\n           lik1,\n           lik2,\n           lik3,\n           options = list(verbose = F,\n                          bru_max_iter = 20,\n                          inla.mode  = \"experimental\"))\n\niinla: Iteration 1 [max:20]\n\n\niinla: Iteration 2 [max:20]\n\n\niinla: Max deviation from previous: 2300% of SD [stop if: <1%]\n\n\niinla: Iteration 3 [max:20]\n\n\niinla: Max deviation from previous: 580% of SD [stop if: <1%]\n\n\niinla: Iteration 4 [max:20]\n\n\niinla: Max deviation from previous: 3980% of SD [stop if: <1%]\n\n\niinla: Iteration 5 [max:20]\n\n\niinla: Max deviation from previous: 3360% of SD [stop if: <1%]\n\n\niinla: Iteration 6 [max:20]\n\n\niinla: Max deviation from previous: 3520% of SD [stop if: <1%]\n\n\niinla: Iteration 7 [max:20]\n\n\niinla: Max deviation from previous: 2970% of SD [stop if: <1%]\n\n\niinla: Iteration 8 [max:20]\n\n\niinla: Max deviation from previous: 2680% of SD [stop if: <1%]\n\n\niinla: Iteration 9 [max:20]\n\n\niinla: Max deviation from previous: 2560% of SD [stop if: <1%]\n\n\niinla: Iteration 10 [max:20]\n\n\niinla: Max deviation from previous: 2350% of SD [stop if: <1%]\n\n\niinla: Iteration 11 [max:20]\n\n\niinla: Max deviation from previous: 2000% of SD [stop if: <1%]\n\n\niinla: Iteration 12 [max:20]\n\n\niinla: Max deviation from previous: 1540% of SD [stop if: <1%]\n\n\niinla: Iteration 13 [max:20]\n\n\niinla: Max deviation from previous: 986% of SD [stop if: <1%]\n\n\niinla: Iteration 14 [max:20]\n\n\niinla: Max deviation from previous: 295% of SD [stop if: <1%]\n\n\niinla: Iteration 15 [max:20]\n\n\niinla: Max deviation from previous: 103% of SD [stop if: <1%]\n\n\niinla: Iteration 16 [max:20]\n\n\niinla: Max deviation from previous: 91.6% of SD [stop if: <1%]\n\n\niinla: Iteration 17 [max:20]\n\n\niinla: Max deviation from previous: 46.4% of SD [stop if: <1%]\n\n\niinla: Iteration 18 [max:20]\n\n\niinla: Max deviation from previous: 54.3% of SD [stop if: <1%]\n\n\niinla: Iteration 19 [max:20]\n\n\niinla: Max deviation from previous: 35.7% of SD [stop if: <1%]\n\n\niinla: Maximum iterations reached, running final INLA integration.\n\n\niinla: Iteration 20 [max:20]\n\nfit2 = bru_rerun(fit2)\n\niinla: Iteration 1 [max:20]\n\n\niinla: Iteration 2 [max:20]\n\n\niinla: Max deviation from previous: 73.2% of SD [stop if: <1%]\n\n\niinla: Iteration 3 [max:20]\n\n\niinla: Max deviation from previous: 113% of SD [stop if: <1%]\n\n\niinla: Iteration 4 [max:20]\n\n\niinla: Max deviation from previous: 85.9% of SD [stop if: <1%]\n\n\niinla: Iteration 5 [max:20]\n\n\niinla: Max deviation from previous: 14.5% of SD [stop if: <1%]\n\n\niinla: Iteration 6 [max:20]\n\n\niinla: Max deviation from previous: 22.1% of SD [stop if: <1%]\n\n\niinla: Iteration 7 [max:20]\n\n\niinla: Max deviation from previous: 9.56% of SD [stop if: <1%]\n\n\niinla: Iteration 8 [max:20]\n\n\niinla: Max deviation from previous: 22.9% of SD [stop if: <1%]\n\n\niinla: Iteration 9 [max:20]\n\n\niinla: Max deviation from previous: 18.8% of SD [stop if: <1%]\n\n\niinla: Iteration 10 [max:20]\n\n\niinla: Max deviation from previous: 16.4% of SD [stop if: <1%]\n\n\niinla: Iteration 11 [max:20]\n\n\niinla: Max deviation from previous: 21.5% of SD [stop if: <1%]\n\n\niinla: Iteration 12 [max:20]\n\n\niinla: Max deviation from previous: 70.9% of SD [stop if: <1%]\n\n\niinla: Iteration 13 [max:20]\n\n\niinla: Max deviation from previous: 124% of SD [stop if: <1%]\n\n\niinla: Iteration 14 [max:20]\n\n\niinla: Max deviation from previous: 99% of SD [stop if: <1%]\n\n\niinla: Iteration 15 [max:20]\n\n\niinla: Max deviation from previous: 42.3% of SD [stop if: <1%]\n\n\niinla: Iteration 16 [max:20]\n\n\niinla: Max deviation from previous: 33% of SD [stop if: <1%]\n\n\niinla: Iteration 17 [max:20]\n\n\niinla: Max deviation from previous: 24.4% of SD [stop if: <1%]\n\n\niinla: Iteration 18 [max:20]\n\n\niinla: Max deviation from previous: 8.55% of SD [stop if: <1%]\n\n\niinla: Iteration 19 [max:20]\n\n\niinla: Max deviation from previous: 21.3% of SD [stop if: <1%]\n\n\niinla: Maximum iterations reached, running final INLA integration.\n\n\niinla: Iteration 20 [max:20]\n\nfit2$summary.fixed\n\n                  mean          sd   0.025quant     0.5quant   0.975quant mode\nIntercept -171.6129153 15.50757943 -201.9385182 -171.6443755 -141.1082990   NA\nbeta_z     -98.7917362 10.34318515 -119.0387045  -98.8052890  -78.4677928   NA\nbeta_u     178.1225745 15.16896988  148.2571723  178.1623897  207.7610651   NA\nalpha_0      0.9753461  0.03485346    0.9069934    0.9753460    1.0436994   NA\nalpha_z      0.5633709  0.03549413    0.4937615    0.5633708    0.6329804   NA\n                   kld\nIntercept 4.409125e-10\nbeta_z    2.104046e-10\nbeta_u    7.122753e-10\nalpha_0   5.522452e-11\nalpha_z   5.527574e-11"
  },
  {
    "objectID": "missing_covariate_imputation.html",
    "href": "missing_covariate_imputation.html",
    "title": "Missing covariate imputation",
    "section": "",
    "text": "In this example, we use the nhanes2 data set from the mice R-package to illustrate how to do missing covariate imputation in INLA by using a measurement error model."
  },
  {
    "objectID": "missing_covariate_imputation.html#specifying-priors",
    "href": "missing_covariate_imputation.html#specifying-priors",
    "title": "Missing covariate imputation",
    "section": "Specifying priors",
    "text": "Specifying priors\n\n# Priors for model of interest coefficients\nprior.beta = c(0, 1/1000) # N(0, 10^3)\n\n# Priors for exposure model coefficients\nprior.alpha <- c(0, 1/10000) # N(0, 10^4) \n\n# Priors for y, measurement error and true x-value precision\nprior.prec.y <- c(0.5, 0.5) # Gamma(0.5, 0.5)\nprior.prec.u_c <- c(0.5, 0.5) # Gamma(0.5, 0.5)\nprior.prec.x <- c(0.5, 0.5) # Gamma(0.5, 0.5) \n\n# Initial values\nprec.y <- 1\nprec.u_c <- 1\nprec.x <- 1"
  },
  {
    "objectID": "missing_covariate_imputation.html#setting-up-the-matrices-for-the-joint-model",
    "href": "missing_covariate_imputation.html#setting-up-the-matrices-for-the-joint-model",
    "title": "Missing covariate imputation",
    "section": "Setting up the matrices for the joint model",
    "text": "Setting up the matrices for the joint model\n\nY <- matrix(NA, 3*n, 3)\n\nY[1:n, 1] <- chl             # Regression model of interest response\nY[n+(1:n), 2] <- bmi         # Error model response\nY[2*n+(1:n), 3] <- rep(0, n) # Exposure model response\n\nbeta.0 <- c(rep(1, n), rep(NA, n), rep(NA, n))\nbeta.x <- c(1:n, rep(NA, n), rep(NA, n))\nbeta.z2 <- c(age2, rep(NA, n), rep(NA, n))\nbeta.z3 <- c(age3, rep(NA, n), rep(NA, n))\n\nid.x <- c(rep(NA, n), 1:n, 1:n) \nweight.x <- c(rep(1, n), rep(1, n), rep(-1, n))\n\nalpha.0 <- c(rep(NA, n), rep(NA, n), rep(1, n))\nalpha.z2 <- c(rep(NA, n), rep(NA, n), age2)\nalpha.z3 <- c(rep(NA, n), rep(NA, n), age3)\n\ndd <- data.frame(Y = Y, \n                 beta.0 = beta.0,\n                 beta.x = beta.x,\n                 beta.z2 = beta.z2,\n                 beta.z3 = beta.z3,\n                 id.x = id.x,\n                 weight.x = weight.x,\n                 alpha.0 = alpha.0,\n                 alpha.z2 = alpha.z2,\n                 alpha.z3 = alpha.z3)"
  },
  {
    "objectID": "missing_covariate_imputation.html#inla-formula",
    "href": "missing_covariate_imputation.html#inla-formula",
    "title": "Missing covariate imputation",
    "section": "INLA formula",
    "text": "INLA formula\n\nformula = Y ~ - 1 + beta.0 + beta.z2 + beta.z3 + \n  f(beta.x, copy=\"id.x\", \n    hyper = list(beta = list(param = prior.beta, fixed=FALSE))) +\n  f(id.x, weight.x, model=\"iid\", values = 1:n, \n    hyper = list(prec = list(initial = -15, fixed=TRUE))) +\n  alpha.0 + alpha.z2 + alpha.z3"
  },
  {
    "objectID": "missing_covariate_imputation.html#scaling-of-me-precision",
    "href": "missing_covariate_imputation.html#scaling-of-me-precision",
    "title": "Missing covariate imputation",
    "section": "Scaling of ME precision",
    "text": "Scaling of ME precision\nSince we are not assuming any measurement error here, we need to “turn off” the error model for the observations where the observation is not missing.\n\n# Scale the measurement error precision according to whether observations are missing or not (1 if missing, large if not missing)\nM <- ifelse(is.na(bmi), 1, 10^12)\nScale <- c(rep(1, n), M, rep(1, n))"
  },
  {
    "objectID": "missing_covariate_imputation.html#fitting-the-model",
    "href": "missing_covariate_imputation.html#fitting-the-model",
    "title": "Missing covariate imputation",
    "section": "Fitting the model",
    "text": "Fitting the model\n\nmodel_missing <- inla(formula, data = dd, scale = Scale,\n                     family = c(\"gaussian\", \"gaussian\", \"gaussian\"),\n                     control.family = list(\n                       list(hyper = list(prec = list(initial = log(prec.y), \n                                                     param = prior.prec.y, \n                                                     fixed = FALSE))),\n                       list(hyper = list(prec = list(initial = log(prec.u_c), \n                                                     param = prior.prec.u_c, \n                                                     fixed = TRUE))),\n                       list(hyper = list(prec = list(initial = log(prec.x), \n                                                     param = prior.prec.x, \n                                                     fixed = FALSE)))\n                     ),\n                     control.fixed = list(\n                       mean = list(beta.0 = prior.beta[1], \n                                   beta.z2 = prior.beta[1], \n                                   beta.z3 = prior.beta[1],  \n                                   alpha.0 = prior.alpha[1], \n                                   alpha.z2 = prior.alpha[1],\n                                   alpha.z3 = prior.alpha[1]), \n                       prec = list(beta.0 = prior.beta[2], \n                                   beta.z2 = prior.beta[2], \n                                   beta.z3 = prior.beta[2],  \n                                   alpha.0 = prior.alpha[2], \n                                   alpha.z2 = prior.alpha[2],\n                                   alpha.z3 = prior.alpha[2])),\n                     verbose=F)\n\n\n# Save results:\nsaveRDS(model_missing, file = \"results/model_missing.rds\")"
  },
  {
    "objectID": "simulation_example.html",
    "href": "simulation_example.html",
    "title": "Simulation example",
    "section": "",
    "text": "library(INLA)\n\\[\n\\def\\na{\\texttt{NA}}\n\\]\nWe here provide a detailed guide to the data simulation and measurement error model used in the simulation study in the paper. This vignette goes through the model in great detail, but only one data set is generated. In the example Simulation study the simulation is run 100 times to ensure that the result are not just due to random variation.\nFor this example, we simulate a linear regression model with a mismeasured covariate \\(\\boldsymbol{x}\\), observed as \\(\\boldsymbol{w}\\), as well as a covariate without measurement error, \\(\\boldsymbol{z}\\). The covariate \\(\\boldsymbol{x}\\) is constructed to have both Berkson and classical measurement error, and it is also missing (completely at random) approximately 20% of the observations.\nSome text from the paper: and the respective likelihood functions for each of the sub-models are passed to the function through the argument. To ensure that the shared term across models is understood to be the same in each sub-model, which in our case is the variable \\(\\boldsymbol{r}\\), we use the feature. The feature can be used to directly copy a term that is shared across the sub-models, or the copied effect can be scaled by a parameter. In this case that parameter is simply a constant vector whose terms are either 1 or -1, with the scaling of 1 corresponding to the term in the main model of interest, and the scaling of -1 corresponding to the imputation model, thus ensuring that \\(\\boldsymbol{x}\\) is on the right hand side of the equation, as described in equation \\(\\eqref{eq:trick}\\)."
  },
  {
    "objectID": "simulation_example.html#data-generation",
    "href": "simulation_example.html#data-generation",
    "title": "Simulation example",
    "section": "Data generation",
    "text": "Data generation\nThe data is generated in the following code.\n\nn <- 1000\n\n# Covariate without error:\nz <- rnorm(n, mean = 0, sd = 1)\n\n# Berkson error:\nw_b <- rnorm(n, mean = 1 + 2*z, sd = 1)\nu_b <- rnorm(n)\nx <- w_b + u_b\n\n# Response:\ny <- 1 + 2*x + 2*z + rnorm(n)\n\n# Classical error:\nu_c <- rnorm(n)\nw_c <- x + u_c  # I think maybe this is incorrect, shouldn't we be using w_b here?\n\n# Missingness:\nm_pred <- -1.5 - 0.5*z # This gives a mean probability of missing of ca 0.2.\nm_prob <- exp(m_pred)/(1 + exp(m_pred))\nm_index <- rbinom(n, 1, prob = m_prob) # MAR\n# m_index <- sample(1:n, 0.2*n, replace = FALSE) # MCAR\nw_c[m_index] <- NA\n\nsimulated_data <- data.frame(y = y, w = w_c, z = z)\n\nThe simulated “observed” data then consists of three columns:\n\\[\n\\boldsymbol{y} \\quad \\boldsymbol{w} \\quad \\boldsymbol{z}\n\\]\nFor \\(n = 1000\\) simulated observations, they contain:\n\n\\(y_1, \\dots, y_n\\): The continuous response.\n\\(w_1, \\dots, w_n\\): A continuous covariate with classical and Berkson measurement error and missing values.\n\\(z_1, \\dots, z_n\\): A continuous covariate.\n\n\nattach(simulated_data)\nn <- nrow(simulated_data)"
  },
  {
    "objectID": "simulation_example.html#model",
    "href": "simulation_example.html#model",
    "title": "Simulation example",
    "section": "Model",
    "text": "Model\nOur response for this model will be\n\\[\ny_i = \\beta_0 + \\beta_x x_i + \\beta_z z_i + \\varepsilon_i \\ , \\quad \\varepsilon_i \\sim N(0, \\tau_y) \\ ,\n\\]\nthe Berkson error model is\n\\[\n  x_i = r_i + u_b \\ , \\quad u_b \\sim N(0, \\tau_{u_b}) \\ ,\n\\]\nthe classical error model is\n\\[\n  r_i = w_i + u_c \\ , \\quad u_c \\sim N(0, \\tau_{u_c}) \\ ,\n\\]\nand the imputation model is\n\\[\nx_i = \\alpha_0 + \\alpha_z z + \\varepsilon_x \\ , \\quad \\varepsilon_x \\sim N(0, \\tau_x)\n\\]\nThe prior distributions are\n\n\\(\\boldsymbol{x} \\sim N(\\alpha_0 + \\alpha_z \\boldsymbol{z}, \\tau_x \\boldsymbol{I})\\),\n\\(\\beta_0, \\beta_x, \\beta_z \\sim N(0, \\tau_{\\beta})\\), with \\(\\tau_{\\beta} = 0.001\\),\n\\(\\alpha_0, \\alpha_z \\sim N(0, \\tau_{\\alpha})\\), with \\(\\tau_{\\alpha} = 0.0001\\)\n\\(\\tau_{y}, \\tau_{u_b}, \\tau_{u_c}, \\tau_{x} \\sim \\text{Gamma}(0.5, 0.5)\\),\n\nWe specify the priors in the code:\n\n# Priors for model of interest coefficients\nprior.beta = c(0, 1/1000) # N(0, 10^3)\n\n# Priors for exposure model coefficients\nprior.alpha <- c(0, 1/10000) # N(0, 10^4)\n  \n# Priors for y, measurement error and true x-value precision\nprior.prec.y <- c(0.5, 0.5) # Gamma(0.5, 0.5)\nprior.prec.u_b <- c(0.5, 0.5) # Gamma(0.5, 0.5)\nprior.prec.u_c <- c(0.5, 0.5) # Gamma(0.5, 0.5)\nprior.prec.x <- c(0.5, 0.5) # Gamma(0.5, 0.5)\n  \n# Initial values\nprec.y <- 1\nprec.u_b <- 1\nprec.u_c <- 1\nprec.x <- 1\n\nThe hierarchical model described in the above section is fit in INLA as a joint model using the \\(\\texttt{copy}\\) feature. We first specify the models in the following matrices and vectors:\n\\[\n\\underbrace{\n\\begin{bmatrix}\n  y_1 & \\na & \\na & \\na \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots \\\\\n  y_n & \\na & \\na & \\na \\\\\n  \\na &  0  & \\na & \\na \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots \\\\\n  \\na &  0  & \\na & \\na \\\\\n  \\na & \\na & w_1 & \\na \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots \\\\\n  \\na & \\na & w_n & \\na \\\\\n  \\na & \\na & \\na &  0  \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots \\\\\n  \\na & \\na & \\na &  0  \\\\\n\\end{bmatrix}\n}_{\\texttt{Y}}\n=\n\\beta_0\n\\underbrace{\n\\begin{bmatrix}\n1 \\\\\n\\vdots \\\\\n1 \\\\\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n\\end{bmatrix}\n}_{\\texttt{beta.0}}\n+ \\beta_x\n\\underbrace{\n\\begin{bmatrix}\n1 \\\\\n\\vdots \\\\\nn \\\\\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n\\end{bmatrix}\n}_{\\texttt{beta.x}}\n+\n\\underbrace{\n\\begin{bmatrix}\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n-1 \\\\\n\\vdots \\\\\n-n \\\\\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n-1 \\\\\n\\vdots \\\\\n-n \\\\\n\\end{bmatrix}\n}_{\\texttt{id.x}}\n+\n\\underbrace{\n\\begin{bmatrix}\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n1 \\\\\n\\vdots \\\\\nn \\\\\n1 \\\\\n\\vdots \\\\\nn \\\\\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n\\end{bmatrix}\n}_{\\texttt{id.r}}\n+ \\beta_z\n\\underbrace{\n\\begin{bmatrix}\nz_1 \\\\\n\\vdots \\\\\nz_n \\\\\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n\\end{bmatrix}\n}_{\\texttt{beta.z}}\n+ \\alpha_0\n\\underbrace{\n\\begin{bmatrix}\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n1 \\\\\n\\vdots \\\\\n1 \\\\\n\\end{bmatrix}\n}_{\\texttt{alpha.0}}\n+ \\alpha_z\n\\underbrace{\n\\begin{bmatrix}\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\n\\na \\\\\n\\vdots \\\\\n\\na \\\\\nz_1 \\\\\n\\vdots \\\\\nz_n \\\\\n\\end{bmatrix}\n}_{\\texttt{alpha.z}}\n\\]\nWe specify these matrices in our code:\n\nY <- matrix(NA, 4*n, 4)\n\nY[1:n, 1] <- y               # Regression model of interest response\nY[n+(1:n), 2] <- rep(0, n)   # Berkson error model response\nY[2*n+(1:n), 3] <- w         # Classical error model response\nY[3*n+(1:n), 4] <- rep(0, n) # Imputation model response\n\nbeta.0 <- c(rep(1, n), rep(NA, 3*n))\nbeta.x <- c(1:n, rep(NA, 3*n))\nbeta.z <- c(z, rep(NA, 3*n))\n\nid.x <- c(rep(NA, n), 1:n, rep(NA, n), 1:n)\nweight.x <- c(rep(1, n), rep(-1, n), rep(1, n), rep(-1, n))\n\nbeta.r <- c(rep(NA, n), 1:n, 1:n, rep(NA, n))\nweight.r <- c(rep(1, 4*n))\n\nalpha.0 = c(rep(NA, 3*n), rep(1, n))\nalpha.z = c(rep(NA, 3*n), z)\n\n\ndd <- data.frame(Y = Y,\n                 beta.0 = beta.0,\n                 beta.x = beta.x,\n                 beta.z = beta.z,\n                 id.x = id.x, \n                 weight.x = weight.x,\n                 beta.r = beta.r,\n                 weight.r = weight.r,\n                 alpha.0 = alpha.0,\n                 alpha.z = alpha.z)\n\nNext, we set up the INLA formula. There are four fixed effects (\\(\\beta_0\\), \\(\\beta_z\\), \\(\\alpha_0\\), \\(\\alpha_z\\)) and three random effects. Two of the random effects are necessary to ensure that the values of \\(\\boldsymbol{r}\\) are the same in the exposure model and error model are assigned the same values as in the regression model, where \\(\\beta_x \\boldsymbol{r}\\) is the product of two unknown quantities. The third random effect term is for encoding the Berkson error model.\n\nf(beta.x, copy=\"id.x\", ...): The copy=\"id.x\" argument ensures that identical values are assigned to \\(\\boldsymbol{x}\\) in all components of the joint model. \\(\\beta_x\\), which is treated as a hyperparameter, is the scaling parameter of the copied process \\(\\boldsymbol{x}^*\\).\nf(id.x, weight.x, ...): id.x contains the \\(\\boldsymbol{x}\\)-values, encoded as an i.i.d. Gaussian random effect, and weighted with weight.x to ensure the correct signs in the joint model. The values option contains the vector of all values assumes by the covariate for which the effect is estimated. The precision prec of the random effect is fixed at \\(\\exp(-15)\\), which is necessary since the uncertainty in \\(\\boldsymbol{x}\\) is already modeled in the second level (column 2 of Y) of the joint model, which defines the imputation component.\nf(beta.r, weight.r, ...):\n\n\nformula = Y ~ - 1 + beta.0 + beta.z +\n  f(beta.x, copy = \"id.x\",  \n    hyper = list(beta = list(param = prior.beta, fixed = FALSE))) +\n  f(id.x, weight.x, model = \"iid\", values = 1:n, \n    hyper = list(prec = list(initial = -15, fixed = TRUE))) +\n  f(beta.r, weight.r, model=\"iid\", values = 1:n, \n    hyper = list(prec = list(initial = -15, fixed = TRUE))) + \n#  f(u.b.tilde, model = \"iid\", values = 1:n,\n#    hyper = list(prec = list(initial = log(1), fixed=TRUE))) +\n  alpha.0 + alpha.z\n\nWe explicitly remove the intercept using -1 since there is no common intercept in the joint model, and the model specific intercepts \\(\\beta_0\\) and \\(\\alpha_0\\) are specified instead.\nNext comes the call of the inla function. We explain further some of the terms:\n\nfamily: Here we need to specify one likelihood function for each of the model levels corresponding to each column in the matrix Y. In this case, they are all Gaussian, but if we for instance had a logistic regression model as our model of interest, then the list would be c(\"binomial\", \"gaussian\", \"gaussian\").\ncontrol.family: Here we specify the hyperparameters for each of the three likelihoods. In this case, we specify the precision for each Gaussian likelihood, \\(\\tau_y\\), \\(\\tau_{u_b}\\), \\(\\tau_{u_c}\\) and \\(\\tau_{x}\\), respectively.\ncontrol.fixed: Prior specification for the fixed effects.\n\n\nmodel_sim <- inla(formula, data = dd, scale = scale.vec,\n                  family = c(\"gaussian\", \"gaussian\", \"gaussian\", \"gaussian\"),\n                  control.family = list(\n                    list(hyper = list(prec = list(initial = log(prec.y),\n                                                  param = prior.prec.y,\n                                                  fixed = FALSE))),\n                    list(hyper = list(prec = list(initial = log(prec.u_b),\n                                                  param = prior.prec.u_b,\n                                                  fixed = TRUE))),\n                    list(hyper = list(prec = list(initial = log(prec.u_c),\n                                                  param = prior.prec.u_c,\n                                                  fixed = TRUE))),\n                    list(hyper = list(prec = list(initial = log(prec.x),\n                                                  param = prior.prec.x,\n                                                  fixed = FALSE)))\n                  ),\n                  control.fixed = list(\n                    mean = list(beta.0 = prior.beta[1],\n                                beta.z = prior.beta[1],\n                                alpha.0 = prior.alpha[1],\n                                alpha.z = prior.alpha[1]),\n                    prec = list(beta.0 = prior.beta[2],\n                                beta.z = prior.beta[2],\n                                alpha.0 = prior.alpha[2],\n                                alpha.z = prior.alpha[2]))\n               )"
  },
  {
    "objectID": "simulation_example.html#results",
    "href": "simulation_example.html#results",
    "title": "Simulation example",
    "section": "Results",
    "text": "Results\n\n# Summary of fixed effects:\nmodel_sim$summary.fixed[1:2]\n\n             mean         sd\nbeta.0  0.6504279 0.13360447\nbeta.z  1.2022995 0.20374379\nalpha.0 0.9936363 0.05961909\nalpha.z 2.0786850 0.05952287\n\n# Summary of random effects:\nmodel_sim$summary.hyperpar[1:2]\n\n                                                mean         sd\nPrecision for the Gaussian observations    7.2369772 2.88312242\nPrecision for the Gaussian observations[4] 0.6552417 0.05596101\nBeta for beta.x                            2.3094190 0.08384926\n\n\nThe fixed effects can then be accessed through model$summary.fixed, whereas the posterior mean and sd for the coefficient of \\(\\boldsymbol{x}\\) can be accessed through model$summary.hyperpar. [todo: what are the two precisions? The precision for the MOI and the imputation model?]\n\n# Save the INLA-model to the package so it can be summarized in the paper.\nsaveRDS(model_sim, file = \"results/model_simulation.rds\")"
  },
  {
    "objectID": "missing_and_mismeasured_covariate.html",
    "href": "missing_and_mismeasured_covariate.html",
    "title": "Missing and mismeasured covariate",
    "section": "",
    "text": "Packages\n\nlibrary(survival)\nlibrary(flexsurv)\nlibrary(boot)\nlibrary(MASS)\nlibrary(rjags)\nlibrary(INLA)\n\n\n\nSetting up the data\n\n# Load data   ==================================================================\nmydata <- read.csv(\"data/bloodpressure.csv\")\nhead(mydata)\n\n  X sbp1 sbp2 sex  age smoke diabetes d         t\n1 1   NA   NA   0 -0.3    NA        0 0 20.833336\n2 2  1.8   NA   0  1.2    NA        1 0  3.250000\n3 3  0.5   NA   0 -0.4    NA        1 0 20.416664\n4 4   NA   NA   1  0.0     1        0 0  4.083336\n5 5  0.5   NA   1 -0.7     1        0 0 12.000000\n6 6 -0.1   NA   1 -1.0     1        0 0 21.166664\n\n\n\n# Create complete-case data set  ===============================================\n\n# For the naive analysis, only the observations that have both sbp1 measurement\n# and smoking status registered are used.\nccaData <- subset(mydata, (is.na(sbp1)==FALSE) & (is.na(smoke)==FALSE))\nn <- dim(ccaData)[1]\n\nhead(ccaData)\n\n    X sbp1 sbp2 sex  age smoke diabetes d        t\n5   5  0.5   NA   1 -0.7     1        0 0 12.00000\n6   6 -0.1   NA   1 -1.0     1        0 0 21.16666\n10 10  1.9   NA   1  2.0     0        0 0  3.25000\n13 13  1.1  0.3   1  0.2     0        0 0 13.66666\n15 15  0.8   NA   1  1.4     0        0 0  2.75000\n16 16 -0.6   NA   1 -0.1     0        0 0  2.50000\n\n# sbp1 sbp2 sex  age smoke diabetes d        t\n# 5   0.5   NA   1 -0.7     1        0 0 12.00000\n# 6  -0.1   NA   1 -1.0     1        0 0 21.16666\n# 10  1.9   NA   1  2.0     0        0 0  3.25000\n# 13  1.1  0.3   1  0.2     0        0 0 13.66666\n# 15  0.8   NA   1  1.4     0        0 0  2.75000\n# 16 -0.6   NA   1 -0.1     0        0 0  2.50000\n\n\n# Function to view relevant INLA coefficient estimates =========================\nview_relevant <- function(INLA_res, model_name){\n  summ <- summary(INLA_res)\n  fixed <- summ$fixed[2:5,1:6]\n  beta.x <- summ$hyperpar[nrow(summ$hyperpar), ]\n  cat(model_name, \"\\n\")\n  rbind(beta.x, fixed)\n}\n\n\n\nNaive Bayesian analysis using INLA\n\n# Note: JAGS and INLA use the same Weibull parameterization\n# (provided \"variant\" = 0 in INLA)\n\nformula.naive <- inla.surv(t/10, d) ~ sbp1 + sex + age + smoke + diabetes\n\nmodel_naive <- inla(formula.naive,\n                     family =\"weibullsurv\",\n                     data=ccaData,\n                     control.family = list(list(variant = 0)))\n\nsummary(model_naive)\n\n\nCall:\n   c(\"inla.core(formula = formula, family = family, contrasts = contrasts, \n   \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \" \n   scale = scale, weights = weights, Ntrials = Ntrials, strata = strata, \n   \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose = \n   verbose, \", \" lincomb = lincomb, selection = selection, control.compute \n   = control.compute, \", \" control.predictor = control.predictor, \n   control.family = control.family, \", \" control.inla = control.inla, \n   control.fixed = control.fixed, \", \" control.mode = control.mode, \n   control.expert = control.expert, \", \" control.hazard = control.hazard, \n   control.lincomb = control.lincomb, \", \" control.update = \n   control.update, control.lp.scale = control.lp.scale, \", \" \n   control.pardiso = control.pardiso, only.hyperparam = only.hyperparam, \n   \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads = \n   num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep, \n   working.directory = working.directory, \", \" silent = silent, inla.mode \n   = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame = \n   .parent.frame)\") \nTime used:\n    Pre = 3.39, Running = 1.19, Post = 0.046, Total = 4.63 \nFixed effects:\n              mean    sd 0.025quant 0.5quant 0.975quant mode kld\n(Intercept) -2.361 0.095     -2.550   -2.360     -2.179   NA   0\nsbp1         0.085 0.036      0.013    0.085      0.156   NA   0\nsex          0.487 0.095      0.303    0.486      0.676   NA   0\nage          0.876 0.058      0.763    0.876      0.989   NA   0\nsmoke        0.262 0.100      0.064    0.263      0.455   NA   0\ndiabetes     0.503 0.112      0.280    0.505      0.718   NA   0\n\nModel hyperparameters:\n                                mean    sd 0.025quant 0.5quant 0.975quant mode\nalpha parameter for weibullsurv 1.42 0.052       1.32     1.42       1.52   NA\n\nMarginal log-Likelihood:  -1385.54 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n\n\n\n\n\n\n\nMeasurement error models (in INLA)\n\n# Estimating sigma_u\nW <- ccaData[,1:2]\nW_mean <- rowMeans(ccaData[,1:2], na.rm = TRUE)\nsigma_uu <- 0\nfor(i in 1:n){\n  k <- sum(!is.na(W[i,])) # count number of repeats (1 or 2)\n  for(j in 1:k){\n    sigma_uu <- sigma_uu + (W[i,j] - W_mean[i])^2\n  }\n}\nsigma_uu <- sigma_uu/sum(is.na(W$sbp2))\n\n# Alternative calculation\nsigma_uu_alt <- (sum((ccaData$sbp1-W_mean)^2) +\n                   sum((ccaData$sbp2-W_mean)^2, na.rm = TRUE)) / sum(is.na(ccaData$sbp2))\n\n\n\nSpecifying priors (used in both ME models)\n\n# Priors for measurement error variance and true x-value\nprior.prec.u <- c(0.5, 0.5) # Gamma(0.5, 0.5) (same as Keogh&Bartlett)\nprior.prec.x <- c(0.5, 0.5) # Gamma(0.5, 0.5) (same as K&B)\n#prec.u = 1/sigma_uu\nprec.u <- 2.8\nprec.x = 1\n\n#curve(dgamma(x, shape = 0.5, rate = 0.5))\n\n# Priors for exposure model coefficients\nprior.alpha <- c(0, 1/10000) # N(0, 10^4) (same as K&B)\n\n# Priors for model of interest coefficients\nprior.beta = c(0, 1/1000) # This has a Gaussian prior\n# (K&B specify prior -beta/r ~ N(0,10^6). Since r has prior Exp(0.001),\n# the expected value of r is 1000, and so if we fix this,\n# we can use prior beta ~ N(0, 1000).)\n\n# Prior for shape parameter of the Weibull survival model\nprior.exp <- 0.01 # Exp(0.001) (INLA sets prior on theta, r~Exp(0.1*theta))\nexp.init <- 1.4\n\n\n\nME model using single measurement\n\n# Specifying Y object\nsurv.time <- c(ccaData$t, rep(NA, 2*n))\nevent <- c(ccaData$d, rep(NA, 2*n))\nY.surv <- inla.surv(surv.time/10, event) # Divide by 10 because of numerical issues otherwise.\nY.expos.sbp <- c(rep(NA, n), rep(0, n), rep(NA, n))\nY.err.sbp <- c(rep(NA, 2*n), ccaData$sbp1) # Use only first measurement from complete case data\nY <- list(Y.surv, Y.expos.sbp, Y.err.sbp)\n\nbeta.0 <- c(rep(1, n), rep(NA, 2*n))\nbeta.sbp <- c(1:n, rep(NA, 2*n))\nbeta.sex <- c(ccaData$sex, rep(NA, 2*n))\nbeta.age <- c(ccaData$age, rep(NA, 2*n))\nbeta.smoke <- c(ccaData$smoke, rep(NA, 2*n))\nbeta.diabetes <- c(ccaData$diabetes, rep(NA, 2*n))\n\nbeta.sbp.copy <- c(rep(NA, n), 1:n, 1:n)\nweight.sbp <- c(rep(NA, n), rep(-1, n), rep(1, n))\n\nalpha.0 <- c(rep(NA, n), rep(1, n), rep(NA, n))\nalpha.sex <- c(rep(NA, n), ccaData$sex, rep(NA, n))\nalpha.age <- c(rep(NA, n), ccaData$age, rep(NA, n))\nalpha.smoke <- c(rep(NA, n), ccaData$smoke, rep(NA, n))\nalpha.diabetes <- c(rep(NA, n), ccaData$diabetes, rep(NA, n))\n\ndd <- list(Y = Y,\n           beta.0 = beta.0,\n           beta.sbp = beta.sbp,\n           beta.sex = beta.sex,\n           beta.age = beta.age,\n           beta.smoke = beta.smoke,\n           beta.diabetes = beta.diabetes,\n           beta.sbp.copy = beta.sbp.copy,\n           weight.sbp = weight.sbp,\n           alpha.0 = alpha.0,\n           alpha.sex = alpha.sex,\n           alpha.age = alpha.age,\n           alpha.smoke = alpha.smoke,\n           alpha.diabetes = alpha.diabetes)\n\n# INLA formula with copy option\nformula = Y ~ beta.0 - 1 +\n  f(beta.sbp.copy, weight.sbp, model=\"iid\", values = 1:n,\n    hyper = list(prec = list(initial = -15, fixed=TRUE))) +\n  f(beta.sbp, copy=\"beta.sbp.copy\",\n    hyper = list(beta = list(param = prior.beta, fixed=FALSE))) +\n  beta.sex + beta.age + beta.smoke + beta.diabetes +\n  alpha.0 + alpha.sex + alpha.age + alpha.smoke + alpha.diabetes\n\nmodel_bloodpressure0 <- inla(formula, data = dd,\n                 family = c(\"weibullsurv\", \"gaussian\", \"gaussian\"),\n                 control.family = list(\n                   list(hyper = list(alpha = list(param = prior.exp,\n                                                  initial = log(exp.init),\n                                                  fixed = FALSE))),\n                   list(hyper = list(prec = list(initial = log(prec.x),\n                                                 param = prior.prec.x,\n                                                 fixed = FALSE))),\n                   list(hyper = list(prec = list(initial = log(prec.u),\n                                                 param = prior.prec.u,\n                                                 fixed = TRUE)))\n                 ),\n                 control.predictor = list(compute = TRUE), #compute pred. dist. of the missing obs in the response\n                 control.fixed = list(\n                   mean = list(beta.0 = prior.beta[1],\n                               beta.sex = prior.beta[1],\n                               beta.age = prior.beta[1],\n                               beta.smoke = prior.beta[1],\n                               beta.diabetes = prior.beta[1],\n                               alpha.0 = prior.alpha[1],\n                               alpha.sex = prior.alpha[1],\n                               alpha.age = prior.alpha[1],\n                               alpha.smoke = prior.alpha[1],\n                               alpha.diabetes = prior.alpha[1]),\n                   prec = list(beta.0 = prior.beta[2],\n                               beta.sex = prior.beta[2],\n                               beta.age = prior.beta[2],\n                               beta.smoke = prior.beta[2],\n                               beta.diabetes = prior.beta[2],\n                               alpha.0 = prior.alpha[2],\n                               alpha.sex = prior.alpha[2],\n                               alpha.age = prior.alpha[2],\n                               alpha.smoke = prior.alpha[2],\n                               alpha.diabetes = prior.alpha[2])),\n                 verbose=F)\nsummary(model_bloodpressure0)\n\n\nCall:\n   c(\"inla.core(formula = formula, family = family, contrasts = contrasts, \n   \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \" \n   scale = scale, weights = weights, Ntrials = Ntrials, strata = strata, \n   \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose = \n   verbose, \", \" lincomb = lincomb, selection = selection, control.compute \n   = control.compute, \", \" control.predictor = control.predictor, \n   control.family = control.family, \", \" control.inla = control.inla, \n   control.fixed = control.fixed, \", \" control.mode = control.mode, \n   control.expert = control.expert, \", \" control.hazard = control.hazard, \n   control.lincomb = control.lincomb, \", \" control.update = \n   control.update, control.lp.scale = control.lp.scale, \", \" \n   control.pardiso = control.pardiso, only.hyperparam = only.hyperparam, \n   \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads = \n   num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep, \n   working.directory = working.directory, \", \" silent = silent, inla.mode \n   = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame = \n   .parent.frame)\") \nTime used:\n    Pre = 3.78, Running = 4.83, Post = 0.126, Total = 8.74 \nFixed effects:\n                 mean    sd 0.025quant 0.5quant 0.975quant mode kld\nbeta.0         -2.368 0.095     -2.557   -2.366     -2.185   NA   0\nbeta.sex        0.490 0.095      0.306    0.490      0.679   NA   0\nbeta.age        0.870 0.059      0.755    0.870      0.985   NA   0\nbeta.smoke      0.263 0.100      0.066    0.264      0.457   NA   0\nbeta.diabetes   0.501 0.112      0.277    0.502      0.715   NA   0\nalpha.0         0.017 0.044     -0.068    0.017      0.103   NA   0\nalpha.sex      -0.065 0.048     -0.158   -0.065      0.029   NA   0\nalpha.age       0.316 0.030      0.257    0.316      0.374   NA   0\nalpha.smoke    -0.002 0.051     -0.103   -0.002      0.099   NA   0\nalpha.diabetes  0.140 0.063      0.017    0.140      0.264   NA   0\n\nRandom effects:\n  Name    Model\n    beta.sbp.copy IID model\n   beta.sbp Copy\n\nModel hyperparameters:\n                                            mean    sd 0.025quant 0.5quant\nalpha parameter for weibullsurv            1.427 0.052      1.329    1.425\nPrecision for the Gaussian observations[2] 1.018 0.038      0.945    1.017\nBeta for beta.sbp                          0.115 0.049      0.018    0.115\n                                           0.975quant mode\nalpha parameter for weibullsurv                 1.534   NA\nPrecision for the Gaussian observations[2]      1.095   NA\nBeta for beta.sbp                               0.213   NA\n\nMarginal log-Likelihood:  -28061.24 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n\nview_relevant(model_bloodpressure0, model_name = \"Single measurement\")\n\nSingle measurement \n\n\n                   mean    sd 0.025quant 0.5quant 0.975quant mode\nBeta for beta.sbp 0.115 0.049      0.018    0.115      0.213   NA\nbeta.sex          0.490 0.095      0.306    0.490      0.679   NA\nbeta.age          0.870 0.059      0.755    0.870      0.985   NA\nbeta.smoke        0.263 0.100      0.066    0.264      0.457   NA\nbeta.diabetes     0.501 0.112      0.277    0.502      0.715   NA\n\n\n\n\n\n\n\nME model using repeated measurements\n\n# Specifying Y object\nsurv.time <- c(ccaData$t, rep(NA, 3*n))\nevent <- c(ccaData$d, rep(NA, 3*n))\nY.surv <- inla.surv(surv.time/10, event)\nY.expos.sbp <- c(rep(NA, n), rep(0, n), rep(NA, 2*n))\nY.err.sbp <- c(rep(NA, 2*n), ccaData$sbp1, ccaData$sbp2) # Use both measurements from complete case data\nY <- list(Y.surv, Y.expos.sbp, Y.err.sbp)\n\nbeta.0 <- c(rep(1, n), rep(NA, 3*n))\nbeta.sbp <- c(1:n, rep(NA, 3*n))\nbeta.sex <- c(ccaData$sex, rep(NA, 3*n))\nbeta.age <- c(ccaData$age, rep(NA, 3*n))\nbeta.smoke <- c(ccaData$smoke, rep(NA, 3*n))\nbeta.diabetes <- c(ccaData$diabetes, rep(NA, 3*n))\n\n# Insert NAs in last model where w is NA\ntt <- 1:n\ntt[is.na(ccaData$sbp2)] <- NA\nbeta.sbp.copy <- c(rep(NA, n), 1:n, 1:n, tt)\nweight.sbp <- c(rep(NA, n), rep(-1, n), rep(1, 2*n))\n\nalpha.0 <- c(rep(NA, n), rep(1, n), rep(NA, 2*n))\nalpha.sex <- c(rep(NA, n), ccaData$sex, rep(NA, 2*n))\nalpha.age <- c(rep(NA, n), ccaData$age, rep(NA, 2*n))\nalpha.smoke <- c(rep(NA, n), ccaData$smoke, rep(NA, 2*n))\nalpha.diabetes <- c(rep(NA, n), ccaData$diabetes, rep(NA, 2*n))\n\n#Scale <- c(rep(1, 4*n) )\n\ndd <- list(Y = Y,\n           beta.0 = beta.0,\n           beta.sbp = beta.sbp,\n           beta.sex = beta.sex,\n           beta.age = beta.age,\n           beta.smoke = beta.smoke,\n           beta.diabetes = beta.diabetes,\n           beta.sbp.copy = beta.sbp.copy,\n           weight.sbp = weight.sbp,\n           alpha.0 = alpha.0,\n           alpha.sex = alpha.sex,\n           alpha.age = alpha.age,\n           alpha.smoke = alpha.smoke,\n           alpha.diabetes = alpha.diabetes#,\n           #Scale = Scale\n           )\n\n# INLA formula with copy option\nformula = Y ~ beta.0 - 1 +\n  f(beta.sbp.copy, weight.sbp, model=\"iid\", values = 1:n,\n    hyper = list(prec = list(initial = -15, fixed=TRUE))) +\n  f(beta.sbp, copy=\"beta.sbp.copy\",\n    hyper = list(beta = list(param = prior.beta, fixed=FALSE))) +\n  beta.sex + beta.age + beta.smoke + beta.diabetes +\n  alpha.0 + alpha.sex + alpha.age + alpha.smoke + alpha.diabetes\n\nmodel_bloodpressure1 <- inla(formula, data = dd,\n                 family = c(\"weibullsurv\", \"gaussian\", \"gaussian\"),\n                 control.family = list(\n                   list(hyper = list(alpha = list(param = prior.exp,\n                                                  initial = log(exp.init),\n                                                  fixed = FALSE))),\n                   list(hyper = list(prec = list(initial = log(prec.x),\n                                                 param = prior.prec.x,\n                                                 fixed = FALSE))),\n                   list(hyper = list(prec = list(initial = log(prec.u),\n                                                 param = prior.prec.u,\n                                                 fixed = FALSE)))\n                 ),\n                 control.predictor=list(link=3),\n                 #scale = Scale,\n                 control.fixed = list(\n                   mean = list(beta.0 = prior.beta[1],\n                               beta.sex = prior.beta[1],\n                               beta.age = prior.beta[1],\n                               beta.smoke = prior.beta[1],\n                               beta.diabetes = prior.beta[1],\n                               alpha.0 = prior.alpha[1],\n                               alpha.sex = prior.alpha[1],\n                               alpha.age = prior.alpha[1],\n                               alpha.smoke = prior.alpha[1],\n                               alpha.diabetes = prior.alpha[1]),\n                   prec = list(beta.0 = prior.beta[2],\n                               beta.sex = prior.beta[2],\n                               beta.age = prior.beta[2],\n                               beta.smoke = prior.beta[2],\n                               beta.diabetes = prior.beta[2],\n                               alpha.0 = prior.alpha[2],\n                               alpha.sex = prior.alpha[2],\n                               alpha.age = prior.alpha[2],\n                               alpha.smoke = prior.alpha[2],\n                               alpha.diabetes = prior.alpha[2])),\n                 verbose=F)\nsummary(model_bloodpressure1)\n\n\nCall:\n   c(\"inla.core(formula = formula, family = family, contrasts = contrasts, \n   \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \" \n   scale = scale, weights = weights, Ntrials = Ntrials, strata = strata, \n   \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose = \n   verbose, \", \" lincomb = lincomb, selection = selection, control.compute \n   = control.compute, \", \" control.predictor = control.predictor, \n   control.family = control.family, \", \" control.inla = control.inla, \n   control.fixed = control.fixed, \", \" control.mode = control.mode, \n   control.expert = control.expert, \", \" control.hazard = control.hazard, \n   control.lincomb = control.lincomb, \", \" control.update = \n   control.update, control.lp.scale = control.lp.scale, \", \" \n   control.pardiso = control.pardiso, only.hyperparam = only.hyperparam, \n   \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads = \n   num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep, \n   working.directory = working.directory, \", \" silent = silent, inla.mode \n   = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame = \n   .parent.frame)\") \nTime used:\n    Pre = 3.76, Running = 8.51, Post = 0.282, Total = 12.6 \nFixed effects:\n                 mean    sd 0.025quant 0.5quant 0.975quant mode kld\nbeta.0         -2.367 0.095     -2.557   -2.366     -2.184   NA   0\nbeta.sex        0.490 0.095      0.306    0.489      0.679   NA   0\nbeta.age        0.871 0.059      0.755    0.871      0.986   NA   0\nbeta.smoke      0.263 0.100      0.065    0.264      0.456   NA   0\nbeta.diabetes   0.502 0.112      0.278    0.503      0.716   NA   0\nalpha.0         0.006 0.043     -0.079    0.006      0.091   NA   0\nalpha.sex      -0.061 0.047     -0.154   -0.061      0.031   NA   0\nalpha.age       0.321 0.030      0.263    0.321      0.379   NA   0\nalpha.smoke     0.002 0.051     -0.098    0.002      0.101   NA   0\nalpha.diabetes  0.134 0.062      0.012    0.134      0.256   NA   0\n\nRandom effects:\n  Name    Model\n    beta.sbp.copy IID model\n   beta.sbp Copy\n\nModel hyperparameters:\n                                            mean    sd 0.025quant 0.5quant\nalpha parameter for weibullsurv            1.428 0.052      1.327    1.427\nPrecision for the Gaussian observations[2] 1.029 0.050      0.935    1.028\nPrecision for the Gaussian observations[3] 2.832 0.259      2.350    2.823\nBeta for beta.sbp                          0.112 0.049      0.014    0.113\n                                           0.975quant mode\nalpha parameter for weibullsurv                 1.530   NA\nPrecision for the Gaussian observations[2]      1.130   NA\nPrecision for the Gaussian observations[3]      3.372   NA\nBeta for beta.sbp                               0.209   NA\n\nMarginal log-Likelihood:  -28337.38 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n\n#saveRDS(inla.res, \"PaperA_ME_and_missing_data/data/KB_inla_res1b.rds\")\n\nview_relevant(model_bloodpressure1, \"Repeated measurement\")\n\nRepeated measurement \n\n\n                   mean    sd 0.025quant 0.5quant 0.975quant mode\nBeta for beta.sbp 0.112 0.049      0.014    0.113      0.209   NA\nbeta.sex          0.490 0.095      0.306    0.489      0.679   NA\nbeta.age          0.871 0.059      0.755    0.871      0.986   NA\nbeta.smoke        0.263 0.100      0.065    0.264      0.456   NA\nbeta.diabetes     0.502 0.112      0.278    0.503      0.716   NA\n\n\n\n\n\n\n\nME model with missingness in SBP1 and SBP2\n\ndata2 <- subset(mydata, is.na(smoke) == FALSE)\nn <- nrow(data2)\n\n# Specifying Y object\nsurv.time <- c(data2$t, rep(NA, 3*n))\nevent <- c(data2$d, rep(NA, 3*n))\nY.surv <- inla.surv(surv.time/10, event)\nY.expos.sbp <- c(rep(NA, n), rep(0, n), rep(NA, 2*n))\nY.err.sbp <- c(rep(NA, 2*n), data2$sbp1, data2$sbp2) # Use all available data\nY <- list(Y.surv, Y.expos.sbp, Y.err.sbp)\n\nbeta.0 <- c(rep(1, n), rep(NA, 3*n))\nbeta.sbp <- c(1:n, rep(NA, 3*n))\nbeta.sex <- c(data2$sex, rep(NA, 3*n))\nbeta.age <- c(data2$age, rep(NA, 3*n))\nbeta.smoke <- c(data2$smoke, rep(NA, 3*n))\nbeta.diabetes <- c(data2$diabetes, rep(NA, 3*n))\n\n# Insert NAs in last model where w is NA\ntt <- 1:n\ntt[is.na(data2$sbp2)] <- NA\nbeta.sbp.copy <- c(rep(NA, n), 1:n, 1:n, tt)\nweight.sbp <- c(rep(NA, n), rep(-1, n), rep(1, 2*n))\n\nalpha.0 <- c(rep(NA, n), rep(1, n), rep(NA, 2*n))\nalpha.sex <- c(rep(NA, n), data2$sex, rep(NA, 2*n))\nalpha.age <- c(rep(NA, n), data2$age, rep(NA, 2*n))\nalpha.smoke <- c(rep(NA, n), data2$smoke, rep(NA, 2*n))\nalpha.diabetes <- c(rep(NA, n), data2$diabetes, rep(NA, 2*n))\n\nScale <- c(rep(1, 4*n) )\n\ndd <- list(Y = Y,\n           beta.0 = beta.0,\n           beta.sbp = beta.sbp,\n           beta.sex = beta.sex,\n           beta.age = beta.age,\n           beta.smoke = beta.smoke,\n           beta.diabetes = beta.diabetes,\n           beta.sbp.copy = beta.sbp.copy,\n           weight.sbp = weight.sbp,\n           alpha.0 = alpha.0,\n           alpha.sex = alpha.sex,\n           alpha.age = alpha.age,\n           alpha.smoke = alpha.smoke,\n           alpha.diabetes = alpha.diabetes,\n           Scale = Scale)\n\n# INLA formula with copy option\nformula = Y ~ beta.0 - 1 +\n  f(beta.sbp.copy, weight.sbp, model=\"iid\", values = 1:n,\n    hyper = list(prec = list(initial = -15, fixed=TRUE))) +\n  f(beta.sbp, copy=\"beta.sbp.copy\",\n    hyper = list(beta = list(param = prior.beta, fixed=FALSE))) +\n  beta.sex + beta.age + beta.smoke + beta.diabetes +\n  alpha.0 + alpha.sex + alpha.age + alpha.smoke + alpha.diabetes\n\nmodel_bloodpressure <- inla(formula, data = dd,\n                 family = c(\"weibull.surv\", \"gaussian\", \"gaussian\"),\n                 control.family = list(\n                   list(hyper = list(alpha = list(param = prior.exp,\n                                                  initial = log(exp.init),\n                                                  fixed = FALSE))),\n                   list(hyper = list(prec = list(initial = log(prec.x),\n                                                 param = prior.prec.x,\n                                                 fixed = FALSE))),\n                   list(hyper = list(prec = list(initial = log(prec.u),\n                                                 param = prior.prec.u,\n                                                 fixed = FALSE)))\n                 ),\n                 control.predictor=list(link=3),\n                 scale = Scale,\n                 control.fixed = list(\n                   mean = list(beta.0 = prior.beta[1],\n                               beta.sex = prior.beta[1],\n                               beta.age = prior.beta[1],\n                               beta.smoke = prior.beta[1],\n                               beta.diabetes = prior.beta[1],\n                               alpha.0 = prior.alpha[1],\n                               alpha.sex = prior.alpha[1],\n                               alpha.age = prior.alpha[1],\n                               alpha.smoke = prior.alpha[1],\n                               alpha.diabetes = prior.alpha[1]),\n                   prec = list(beta.0 = prior.beta[2],\n                               beta.sex = prior.beta[2],\n                               beta.age = prior.beta[2],\n                               beta.smoke = prior.beta[2],\n                               beta.diabetes = prior.beta[2],\n                               alpha.0 = prior.alpha[2],\n                               alpha.sex = prior.alpha[2],\n                               alpha.age = prior.alpha[2],\n                               alpha.smoke = prior.alpha[2],\n                               alpha.diabetes = prior.alpha[2])),\n                 verbose=F)\nsummary(model_bloodpressure)\n\n\nCall:\n   c(\"inla.core(formula = formula, family = family, contrasts = contrasts, \n   \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \" \n   scale = scale, weights = weights, Ntrials = Ntrials, strata = strata, \n   \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose = \n   verbose, \", \" lincomb = lincomb, selection = selection, control.compute \n   = control.compute, \", \" control.predictor = control.predictor, \n   control.family = control.family, \", \" control.inla = control.inla, \n   control.fixed = control.fixed, \", \" control.mode = control.mode, \n   control.expert = control.expert, \", \" control.hazard = control.hazard, \n   control.lincomb = control.lincomb, \", \" control.update = \n   control.update, control.lp.scale = control.lp.scale, \", \" \n   control.pardiso = control.pardiso, only.hyperparam = only.hyperparam, \n   \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads = \n   num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep, \n   working.directory = working.directory, \", \" silent = silent, inla.mode \n   = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame = \n   .parent.frame)\") \nTime used:\n    Pre = 3.92, Running = 8.66, Post = 0.145, Total = 12.7 \nFixed effects:\n                 mean    sd 0.025quant 0.5quant 0.975quant mode kld\nbeta.0         -2.280 0.080     -2.439   -2.279     -2.125   NA   0\nbeta.sex        0.444 0.079      0.291    0.444      0.601   NA   0\nbeta.age        0.906 0.050      0.808    0.906      1.004   NA   0\nbeta.smoke      0.272 0.085      0.104    0.272      0.436   NA   0\nbeta.diabetes   0.595 0.093      0.409    0.596      0.775   NA   0\nalpha.0         0.006 0.043     -0.078    0.006      0.091   NA   0\nalpha.sex      -0.062 0.047     -0.154   -0.062      0.030   NA   0\nalpha.age       0.323 0.030      0.265    0.323      0.381   NA   0\nalpha.smoke     0.005 0.051     -0.094    0.005      0.104   NA   0\nalpha.diabetes  0.138 0.062      0.016    0.138      0.260   NA   0\n\nRandom effects:\n  Name    Model\n    beta.sbp.copy IID model\n   beta.sbp Copy\n\nModel hyperparameters:\n                                            mean    sd 0.025quant 0.5quant\nalpha parameter for weibullsurv            1.379 0.042      1.296    1.379\nPrecision for the Gaussian observations[2] 1.029 0.050      0.934    1.028\nPrecision for the Gaussian observations[3] 2.826 0.260      2.346    2.814\nBeta for beta.sbp                          0.114 0.049      0.018    0.114\n                                           0.975quant mode\nalpha parameter for weibullsurv                  1.46   NA\nPrecision for the Gaussian observations[2]       1.13   NA\nPrecision for the Gaussian observations[3]       3.37   NA\nBeta for beta.sbp                                0.21   NA\n\nMarginal log-Likelihood:  -35207.93 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n\n#saveRDS(inla.res2, \"PaperA_ME_and_missing_data/data/KB_inla_res2.rds\")\n\nview_relevant(model_bloodpressure, \"Repeated measurement\")\n\nRepeated measurement \n\n\n                   mean    sd 0.025quant 0.5quant 0.975quant mode\nBeta for beta.sbp 0.114 0.049      0.018    0.114      0.210   NA\nbeta.sex          0.444 0.079      0.291    0.444      0.601   NA\nbeta.age          0.906 0.050      0.808    0.906      1.004   NA\nbeta.smoke        0.272 0.085      0.104    0.272      0.436   NA\nbeta.diabetes     0.595 0.093      0.409    0.596      0.775   NA\n\n\n\n\n\n\n\nLook at all models\n\nres.naive <- readRDS(\"PaperA_ME_and_missing_data/data/KB_inla_res0.rds\")\nres.singlemes <- readRDS(\"PaperA_ME_and_missing_data/data/KB_inla_res1a.rds\")\nres.repmeas <- readRDS(\"PaperA_ME_and_missing_data/data/KB_inla_res1b.rds\")\nres.complbp <- readRDS(\"PaperA_ME_and_missing_data/data/KB_inla_res2.rds\")\n\n\n# Corresponds to Naive?\nview_relevant(res.naive, \"Naive model\")\n# No corresponding model in KB\nview_relevant(res.singlemes, \"Single SBP measurement (only complete cases of SBP1 and smoking)\")\n# Corresponds to Bayes^c?\nview_relevant(res.repmeas, \"Repeated SBP measurement (only complete cases of SBP1 and smoking)\")\n# Would correspond to Bayes^d if we had exposure model for smoking\nview_relevant(res.complbp, \"Missingness in both SBP measurements (only complete cases of smoking)\")"
  },
  {
    "objectID": "index.html#datasets",
    "href": "index.html#datasets",
    "title": "Supplementary material and reproducible research files for article “A Joint Bayesian Framework for Measurement Error and Missing Data using Integrated Nested Laplace Approximations”",
    "section": "Datasets",
    "text": "Datasets\nAll the data sets that are used in the paper can be downloaded manually from [link to github repo], or like this:\n\n# Code to download data"
  },
  {
    "objectID": "loading_data.html",
    "href": "loading_data.html",
    "title": "Datasets",
    "section": "",
    "text": "The examples in this paper use three different datasets."
  },
  {
    "objectID": "missing_covariate_imputation.html#loading-packages",
    "href": "missing_covariate_imputation.html#loading-packages",
    "title": "Missing covariate imputation",
    "section": "Loading packages",
    "text": "Loading packages\n\nlibrary(mice)    # Just used for the nhanes2 data set\nlibrary(INLA)    # INLA modelling\nlibrary(dplyr)   # Data wrangling of the results"
  },
  {
    "objectID": "missing_covariate_imputation.html#loading-and-preparing-the-data",
    "href": "missing_covariate_imputation.html#loading-and-preparing-the-data",
    "title": "Missing covariate imputation",
    "section": "Loading and preparing the data",
    "text": "Loading and preparing the data\n\n# Using the nhanes data set found in mice so we can compare to mice:\ndata(nhanes2)\n\nn <- nrow(nhanes2)\n\n# Manualy dummy-code age:\nage2 <- ifelse(nhanes2$age == \"40-59\", 1, 0)\nage3 <- ifelse(nhanes2$age == \"60-99\", 1, 0)\n\n# Center the response and continuous covariates\nchl <- scale(nhanes2$chl, scale = FALSE)[,1]\nbmi <- scale(nhanes$bmi, scale = FALSE)[,1]"
  },
  {
    "objectID": "missing_covariate_imputation.html#modelling",
    "href": "missing_covariate_imputation.html#modelling",
    "title": "Missing covariate imputation",
    "section": "Modelling",
    "text": "Modelling\nWe want to fit the model\n\\[\nchl \\sim \\beta_0 + \\beta_1 age_2 + \\beta_2 age_3 + \\beta_3 bmi\n\\]\nTODO: Coefficient names are not consistent\n\nSpecifying priors\n\n# Priors for model of interest coefficients\nprior.beta = c(0, 1/1000) # N(0, 10^3)\n\n# Priors for exposure model coefficients\nprior.alpha <- c(0, 1/10000) # N(0, 10^4) \n\n# Priors for y, measurement error and true x-value precision\nprior.prec.y <- c(0.5, 0.5) # Gamma(0.5, 0.5)\nprior.prec.u_c <- c(0.5, 0.5) # Gamma(0.5, 0.5)\nprior.prec.x <- c(0.5, 0.5) # Gamma(0.5, 0.5) \n\n# Initial values\nprec.y <- 1\nprec.u_c <- 1\nprec.x <- 1\n\n\n\nSetting up the matrices for the joint model\n\nY <- matrix(NA, 3*n, 3)\n\nY[1:n, 1] <- chl             # Regression model of interest response\nY[n+(1:n), 2] <- bmi         # Error model response\nY[2*n+(1:n), 3] <- rep(0, n) # Exposure model response\n\nbeta.0 <- c(rep(1, n), rep(NA, n), rep(NA, n))\nbeta.x <- c(1:n, rep(NA, n), rep(NA, n))\nbeta.z2 <- c(age2, rep(NA, n), rep(NA, n))\nbeta.z3 <- c(age3, rep(NA, n), rep(NA, n))\n\nid.x <- c(rep(NA, n), 1:n, 1:n) \nweight.x <- c(rep(1, n), rep(1, n), rep(-1, n))\n\nalpha.0 <- c(rep(NA, n), rep(NA, n), rep(1, n))\nalpha.z2 <- c(rep(NA, n), rep(NA, n), age2)\nalpha.z3 <- c(rep(NA, n), rep(NA, n), age3)\n\ndd <- data.frame(Y = Y, \n                 beta.0 = beta.0,\n                 beta.x = beta.x,\n                 beta.z2 = beta.z2,\n                 beta.z3 = beta.z3,\n                 id.x = id.x,\n                 weight.x = weight.x,\n                 alpha.0 = alpha.0,\n                 alpha.z2 = alpha.z2,\n                 alpha.z3 = alpha.z3)\n\n\n\nINLA formula\n\nformula = Y ~ - 1 + beta.0 + beta.z2 + beta.z3 + \n  f(beta.x, copy=\"id.x\", \n    hyper = list(beta = list(param = prior.beta, fixed=FALSE))) +\n  f(id.x, weight.x, model=\"iid\", values = 1:n, \n    hyper = list(prec = list(initial = -15, fixed=TRUE))) +\n  alpha.0 + alpha.z2 + alpha.z3\n\n\n\nScaling of ME precision\nSince we are not assuming any measurement error here, we need to “turn off” the error model for the observations where the observation is not missing.\n\n# Scale the measurement error precision according to whether observations are missing or not (1 if missing, large if not missing)\nM <- ifelse(is.na(bmi), 1, 10^12)\nScale <- c(rep(1, n), M, rep(1, n))\n\n\n\nFitting the model\n\nmodel_missing <- inla(formula, data = dd, scale = Scale,\n                     family = c(\"gaussian\", \"gaussian\", \"gaussian\"),\n                     control.family = list(\n                       list(hyper = list(prec = list(initial = log(prec.y), \n                                                     param = prior.prec.y, \n                                                     fixed = FALSE))),\n                       list(hyper = list(prec = list(initial = log(prec.u_c), \n                                                     param = prior.prec.u_c, \n                                                     fixed = TRUE))),\n                       list(hyper = list(prec = list(initial = log(prec.x), \n                                                     param = prior.prec.x, \n                                                     fixed = FALSE)))\n                     ),\n                     control.fixed = list(\n                       mean = list(beta.0 = prior.beta[1], \n                                   beta.z2 = prior.beta[1], \n                                   beta.z3 = prior.beta[1],  \n                                   alpha.0 = prior.alpha[1], \n                                   alpha.z2 = prior.alpha[1],\n                                   alpha.z3 = prior.alpha[1]), \n                       prec = list(beta.0 = prior.beta[2], \n                                   beta.z2 = prior.beta[2], \n                                   beta.z3 = prior.beta[2],  \n                                   alpha.0 = prior.alpha[2], \n                                   alpha.z2 = prior.alpha[2],\n                                   alpha.z3 = prior.alpha[2])),\n                     verbose=F)\n\n\n# Save results:\nsaveRDS(model_missing, file = \"results/model_missing.rds\")"
  },
  {
    "objectID": "missing_covariate_imputation.html#results",
    "href": "missing_covariate_imputation.html#results",
    "title": "Missing covariate imputation",
    "section": "Results",
    "text": "Results\nThe posterior means and standard deviations are presented in the table below.\n\n\n\n\n\n\n\n\n\n  \n  \n    \n      \n      mean\n      sd\n    \n  \n  \n    \n      Model of interest\n    \n    beta.0\n-15.259895\n11.843351\n    beta.z2\n25.350963\n17.688393\n    beta.z3\n42.296261\n21.473338\n    Beta for beta.x\n3.098605\n1.401834\n    \n      Imputation model\n    \n    alpha.0\n1.828934\n1.509489\n    alpha.z2\n-2.970462\n2.354992\n    alpha.z3\n-3.849004\n2.497979"
  },
  {
    "objectID": "loading_data.html#nhanes-example",
    "href": "loading_data.html#nhanes-example",
    "title": "Datasets",
    "section": "NHANES example",
    "text": "NHANES example\nA small data set with missing values.\n\nLoad the data\n\nlibrary(mice)\n\n\nAttaching package: 'mice'\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\nThe following objects are masked from 'package:base':\n\n    cbind, rbind\n\ndata(nhanes2)\n\n\n\nFormat\nA data frame with 25 rows and 4 variables:\n\nage: Age group (1=20-39, 2=40-59, 3=60+)\nbmi: Age group (1=20-39, 2=40-59, 3=60+)\nhyp: Hypertensive (1=no,2=yes)\nchl: Total serum cholesterol (mg/dL)\n\n\n\nSource\nThe {mice} package, originally from Schafer, J.L. (1997). Analysis of Incomplete Multivariate Data. London: Chapman & Hall. Table 6.14."
  },
  {
    "objectID": "loading_data.html#simulated-data-with-measurement-error-and-missing-values",
    "href": "loading_data.html#simulated-data-with-measurement-error-and-missing-values",
    "title": "Datasets",
    "section": "Simulated data with measurement error and missing values",
    "text": "Simulated data with measurement error and missing values\nA dataset containing three simulated variables, generated in the example “Simulation: Berkson and classical measurement error alongside missing data”.\n\nLoad the data\n\nsimulated_data <- read.csv(\"data/simulated_data.csv\")\n\n\n\nFormat\nA data frame with 1000 rows and 3 variables:\n\ny: response variable, continuous\nw: covariate with classical and Berkson measurement error, and missing data, continuous\nz: covariate with no error or missingness, continuous"
  },
  {
    "objectID": "loading_data.html#bloodpressure-data",
    "href": "loading_data.html#bloodpressure-data",
    "title": "Datasets",
    "section": "Bloodpressure data",
    "text": "Bloodpressure data\nRepeated systolic blood pressure measurements with measurement error.\nA dataset containing a repeated blood pressure measurement along with some other variables for participants in the Third National Health and Nutrition Survey (NHANES III), merged with data from the US National Death Index by Ruth H. Keogh and Jonathan Bartlett.\n\nLoad the data\n\nbloodpressure <- read.csv(\"data/bloodpressure.csv\")\n\n\n\nFormat\nA data frame with 6519 rows and 8 variables:\n\nsbp1: systolic blood pressure (standardized), first measurement\nsbp2: systolic blood pressure (standardized), second measurement\nsex: Sex (0 = ?, 1 = ?)\nage: Age (standardized)\nsmoke: Smoking status (0 = no, 1 = yes)\ndiabetes: diabetes status (0 = no, 1 = yes)\nd: censoring status (0 = censored, 1 = observed death due to cardiovascular disease)\nt: time until death due to cardiovascular disease occurs\n\n\n\nSource\nhttps://github.com/ruthkeogh/meas_error_handbook"
  }
]