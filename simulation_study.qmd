---
title: "Simulation study"
execute: 
  freeze: true
---

```{r}
#| label: setup
#| message: false
library(INLA)
library(inlabru)
library(tidyverse)
```

In the vignette [Simulation example](Simulation_example.Rmd), we simulate a single data set with Berkson error, classical error and missing data, and then fit a measurement error model to adjust for these errors. In this simulation study, we do the exact same steps, but repeated on 100 simulated data sets instead of just one, to ensure that the results are not an artifact of one particular data set. This vignette consists of mostly just code, for detailed explanations on the steps taken in the analysis, please refer to [Simulation example](Simulation_example.Rmd).


TODO: The model in this vignette still uses the random effect berkson model, this needs to be changes. Make sure model is consistent with the model in the Simulation example vignette.

## Setting up functions

### Function for simulating data

```{r}
#| label: function for data simulation
simulate_data <- function(n){
  # Covariate without error:
  z <- rnorm(n, mean = 0, sd = 1)
  # Berkson error:
  u_b <- rnorm(n)
  w_b <- rnorm(n, mean = 1 + 2*z, sd = 1)
  x <- w_b + u_b
  # Response:
  y <- 1 + 2*x + 2*z + rnorm(n)
  # Classical error:
  u_c <- rnorm(n)
  w_c <- x + u_c # I think maybe this is incorrect, shouldn't we be using w_b here?
  # Missingness:
  m_pred <- -1.5 - 0.5*z # This gives a mean probability of missing of ca 0.2.
  m_prob <- exp(m_pred)/(1 + exp(m_pred))
  m_index <- rbinom(n, 1, prob = m_prob) # MAR
  # m_index <- sample(1:n, 0.2*n, replace = FALSE) # MCAR
  w_c[m_index] <- NA

  simulated_data <- data.frame(y = y, w = w_c, z = z, x = x)
  return(simulated_data)
}
```

### Functions for setting up the model matrices

```{r}
#| label: functions for model matrices
# Make matrix for ME model
make_matrix_ME <- function(data){
  n <- nrow(data)
  
  y <- data$y
  w <- data$w
  z <- data$z
  
  # Measurement error model
  Y <- matrix(NA, 3*n, 3)
  
  Y[1:n, 1] <- y               # Regression model of interest response
  Y[n+(1:n), 2] <- w           # Error model response
  Y[2*n+(1:n), 3] <- rep(0, n) # Exposure model response
  
  beta.0 <- c(rep(1, n), rep(NA, 2*n))
  beta.x <- c(1:n, rep(NA, n), rep(NA, n))
  u.b.tilde <- c(1:n, rep(NA, n), rep(NA, n))
  beta.z <- c(z, rep(NA, 2*n))
  
  id.r <- c(rep(NA, n), 1:n, 1:n)
  weight.r <- c(rep(1, n), rep(1, n), rep(-1, n))
  
  alpha.0 = c(rep(NA, n), rep(NA, n), rep(1, n))
  alpha.z = c(rep(NA, n), rep(NA, n), z)
  dd_adj <- list(Y = Y,
                   beta.0 = beta.0,
                   beta.x = beta.x,
                   u.b.tilde = u.b.tilde,
                   beta.z = beta.z,
                   id.r = id.r,
                   weight.r = weight.r,
                   alpha.0 = alpha.0,
                   alpha.z = alpha.z)

  return(dd_adj)
}

# Make matrix for naive model
make_matrix_naive <- function(data){
  y <- data$y
  w <- data$w
  z <- data$z
  
  # Naive model
  dd_naive <- data.frame(Y = y,
                         beta.0 = rep(1, nrow(data)),
                         beta.x = w, 
                         beta.z = z)
  return(dd_naive)
}

# Make matrix for model using the unobserved variable
make_matrix_true <- function(data){
  y <- data$y
  x <- data$x
  z <- data$z
  # True model
  dd_naive <- data.frame(Y = y,
                         beta.0 = rep(1, nrow(data)),
                         beta.x = x, 
                         beta.z = z)
}
```


### Function for fitting the ME model
```{r}
#| label: function for fitting ME model
# Fit ME model
fit_model_ME <- function(data_matrix) {
  # Priors for model of interest coefficients
  prior.beta <- c(0, 1/1000) # N(0, 10^3)
  
  # Priors for exposure model coefficients
  prior.alpha <- c(0, 1/10000) # N(0, 10^4)
  
  # Priors for y, measurement error and true x-value precision
  prior.prec.y <- c(0.5, 0.5) # Gamma(0.5, 0.5)
  prior.prec.u_b <- c(0.5, 0.5) # Gamma(0.5, 0.5)
  prior.prec.u_c <- c(0.5, 0.5) # Gamma(0.5, 0.5)
  prior.prec.x <- c(0.5, 0.5) # Gamma(0.5, 0.5)
  
  # Initial values
  prec.y <- 1
  prec.u_b <- 1
  prec.u_c <- 1
  prec.x <- 1
  
  # Formula
  formula <- Y ~ beta.0 - 1 +
    f(beta.x, copy="id.r",
      hyper = list(beta = list(param = prior.beta, fixed=FALSE))) +
    f(id.r, weight.r, model="iid", values = 1:n,
      hyper = list(prec = list(initial = -15, fixed=TRUE))) +
    f(u.b.tilde, model = "iid", values = 1:n,
      hyper = list(prec = list(initial = log(1), fixed=TRUE))) +
    beta.z + alpha.0 + alpha.z
  
  # Fit model
  model <- inla(formula,
                data = data_matrix,
                family = c("gaussian", "gaussian", "gaussian"),
                control.family = list(
                  list(hyper = list(prec = list(initial = log(prec.y), 
                                                param = prior.prec.y, 
                                                fixed = FALSE))), 
                  list(hyper = list(prec = list(initial = log(prec.u_c), 
                                                param = prior.prec.u_c, 
                                                fixed = TRUE))), 
                  list(hyper = list(prec = list(initial = log(prec.x), 
                                                param = prior.prec.x, 
                                                fixed = FALSE)))), 
                control.predictor = list(compute = TRUE), 
                control.fixed = list(
                  mean = list(
                    beta.0 = prior.beta[1],
                    beta.z = prior.beta[1],
                    alpha.0 = prior.alpha[1],
                    alpha.z = prior.alpha[1]),
                  prec = list(
                    beta.0 = prior.beta[2],
                    beta.z = prior.beta[2],
                    alpha.0 = prior.alpha[2],
                    alpha.z = prior.alpha[2])
    )
  )
}
```

### Function for fitting the true/naive model

The same function can be used to fit the naive model (`y ~ w + z`) and the best-case model (`y ~ x + z`) since they simply differ in the variable that is inputted (`w` versus `x`).

```{r}
#| label: function for fitting true/naive model
fit_model_naive_true <- function(data_matrix){
  # Priors for model of interest coefficients
  prior.beta <- c(0, 1/1000) # N(0, 10^3)

  # Priors for y, measurement error and true x-value precision
  prior.prec.y <- c(0.5, 0.5) # Gamma(0.5, 0.5)
  
  # Initial values
  prec.y <- 1

  # Formula
  formula <- Y ~ beta.0 - 1 + beta.x + beta.z
  
  # Fit model
  model <- inla(formula,
                data = data_matrix,
                family = c("gaussian"),
                control.family = list(
                  list(hyper = list(prec = list(initial = log(prec.y), 
                                                param = prior.prec.y, 
                                                fixed = FALSE)))),
                control.fixed = list(
                  mean = list(
                    beta.0 = prior.beta[1],
                    beta.z = prior.beta[1],
                    beta.x = prior.beta[1]),
                  prec = list(
                    beta.0 = prior.beta[2],
                    beta.z = prior.beta[2],
                    beta.x = prior.beta[2])
    )
  )
}
```



## Fitting the model for each data set

We simulate 100 data sets and fit the model that accounts for measurement error and missing data, and then save the posterior means for the intercept ans slopes.

Note that this chunk may take a while to run.

```{r}
#| label: running the simulation 
# Number of iterations
niter <- 20

# Data frames to store the results 
results_ME <- data.frame(matrix(NA, nrow=niter, ncol=5))
names(results_ME) <- c("beta.0", "beta.x", "beta.z", "alpha.0", "alpha.z")

results_naive <- data.frame(matrix(NA, nrow=niter, ncol=3))
names(results_naive) <- c("beta.0", "beta.x", "beta.z")

results_true <- data.frame(matrix(NA, nrow=niter, ncol=3))
names(results_true) <- c("beta.0", "beta.x", "beta.z")


for(i in 1:niter){
  n <- 1000
  data <- simulate_data(n)
  
  # ME model
  matrix_ME <- make_matrix_ME(data)
  model_ME <- fit_model_ME(matrix_ME)
  
  # Naive model
  matrix_naive <- make_matrix_naive(data)
  model_naive <- fit_model_naive_true(matrix_naive)
  
  # True model
  matrix_true <- make_matrix_true(data)
  model_true <- fit_model_naive_true(matrix_true)
  
  results_ME[i, c("beta.0", "beta.z", 
                  "alpha.0", "alpha.z")] <- t(model_ME$summary.fixed["mean"])
  results_ME[i, "beta.x"] <- model_ME$summary.hyperpar[3, "mean"]
  
  results_naive[i, c("beta.0", "beta.z", "beta.x")] <- t(model_naive$summary.fixed["mean"])
  
  results_true[i, c("beta.0", "beta.z", "beta.x")] <- t(model_true$summary.fixed["mean"])

}

```

## Results

```{r}
#| label: visualizing results
#| echo: false
#| fig.showtext: true
library(ggplot2)
library(showtext)
library(ghibli)

## Boxplot
joint_results <- bind_rows(ME = results_ME, 
                           naive = results_naive, 
                           true = results_true, 
                           .id = "model") |> 
  pivot_longer(cols = 2:6, names_to = "variable") |> 
  filter(variable %in% c("beta.0", "beta.z", "beta.x")) |> 
  mutate(variable = tools::toTitleCase(gsub(pattern = ".*beta.", replacement = "", variable)))

truth <- data.frame(variable = c(1, 2, 3), value = c(1, 2, 2), model = "ME")

# Colors ----
col_bgr <- "#FFFCFC"
col_text <- "#191919"

# Loading fonts ----
f1 <- "Open Sans"
f2 <- "Open Sans"
font_add_google(name = f1, family = f1)
font_add_google(name = f2, family = f2)

showtext_opts(dpi = 300)

theme_titles <- theme(
    # This is the new default font in the plot
    text = element_text(family = f1, size = 10, color = col_text),
    plot.title = element_text(
      family = f1, 
      size = 15
    ),
    # Statistical annotations below the main title
    plot.subtitle = element_text(
      family = f1, 
      size = 15 
    ),
    plot.title.position = "plot", # slightly different from default
    axis.title.x = element_blank(),
    axis.title.y = element_text(angle = 0, hjust = 1),
    axis.text = element_text(size = 10),
    axis.ticks = element_blank(),
    axis.line = element_line(colour = "grey40"),
    legend.title = element_blank(),
    legend.position = "top",
    legend.text = element_text(size = 10),
    panel.grid = element_line(color = "#b4aea9"),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.major.y = element_line(linetype = "dashed"),
    panel.background = element_rect(fill = "#fbf9f4", color = "#fbf9f4"),
    plot.background = element_rect(fill = "#fbf9f4", color = "#fbf9f4"),
    plot.margin = margin(10, 50, 10, 10)
  )

ggplot(joint_results, aes(x = variable, y = value, groups = model)) +
  geom_segment(data = truth, aes(x = variable - 0.45, xend = variable + 0.45, 
                                 y = value, yend = value), 
               size = 1, color = "cornsilk4", lineend = "round") +
  geom_boxplot(color = col_text, outlier.shape=NA, fill = NA) +
  geom_point(aes(color = model), alpha = 0.8, size = 1.5,
             position=position_jitterdodge(jitter.width = 0.2)) +
  scale_x_discrete(labels = scales::label_math(expr = beta[.x])) +
  #scale_colour_manual(values = ghibli_palettes$PonyoMedium[c(3, 5, 6)], labels = c("ME model", "y ~ w + z", "y ~ x + z")) +
  scale_color_manual(values = ggthemes::canva_palettes$"Pool party"[c(1,3,4)], labels = c("ME model", "y ~ w + z", "y ~ x + z")) +
  ylab("Posterior\nmean") +
  theme_minimal() +
  theme_titles

#ggsave("simulation_boxplot.png", width = 6, height = 4)
```


```{r}
saveRDS(joint_results, file = "results/simulation_results.rds")
```


```{r, echo = FALSE, eval = FALSE}
library(tidyverse)

means <- sapply(results, FUN = mean)
sdevs <- sapply(results, FUN = sd)

table_data <- data.frame(mean = means, sd = sdevs)

est_table <- table_data[c("mean", "sd")] %>%
    dplyr::mutate_if(is.numeric, round, digits = 3) %>%
    dplyr::mutate(Estimate = paste0(mean, " (", sd, ")"))
beta_rows <- grepl("beta", row.names(est_table))
greekletter <- ifelse(beta_rows, "beta", "alpha")
# subscript <- sub(".*[.]", "", row.names(est_table))
row.names(est_table) <- paste0("$", "\\", greekletter, "_{", c("0", "x", "z", "0", "z"), "}", "$")

final.table <- est_table %>% select(Estimate)

results %>% pivot_longer(cols = 1:5, names_to = "variable") %>% 
  ggplot(aes(x = variable, y = value)) +
  geom_boxplot() +
  theme_bw()
```

